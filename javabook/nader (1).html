    <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <title>Java for Android Explorers: A Beginner's Handbook by Nader Mahbub Khan</title>
  <link rel="stylesheet" href="styles/github.min.css">
  <script src="highlight.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <page><center><h1>Java for Android Explorers</h1>
   <h2>A Beginner's Handbook</h2>
    <h2>First Edition</h2>
  <h2>Muhammad Nader Mahbub Khan</h2>
  <h4>Self Taught Programmer, Android and Web Developer</h4>
  <table>
    <tr>
      <td>
        
          <b>Unauthorized copying, reprinting, or republishing of any material from this book without the express written permission of the author is strictly prohibited. Violators may be subject to legal action and penalties under copyright law.</b>
          <br><br>
          For permissions or inquiries, please contact:<br><br>
          
          Muhammad Nader Mahbub Khan (Nabil)<br>
          Email: muhammadnadermahbubkhan@gmail.com
      </td>
    </tr>
  </table>
  <br>
  <center>Generated at:
    <font face="Monospace" style="font-weight:bold">
      <span id="date"></span>
    </font><br>
  
    Copyright Â© 2023, Muhammad Nader Mahbub Khan. All rights reserved.
  </center>
  </center></page>
  <br>
  <page>
    <h2>Table of Contents</h2>
    <table>
  <tr>
    <th>Lesson</th>
    <th>Topic</th>
    <th>Page</th>
  </tr>
  <tr>
    <td>Lesson 01</td>
    <td>Intro into Java</td>
    <td>Page 1</td>
  </tr>
  <tr>
    <td>Lesson 02</td>
    <td>How does Java work?</td>
    <td>Page 5</td>
  </tr>
  <tr>
    <td>Lesson 03</td>
    <td>Basic structure of a Java program</td>
    <td>Page 12</td>
  </tr>
  <tr>
    <td>Lesson 04</td>
    <td>Datatypes, Variables, Keywords, Literals, and Comments</td>
    <td>Page 18</td>
  </tr>
  <tr>
    <td>Lesson 05</td>
    <td>Read input from keyboard</td>
    <td>Page 26</td>
  </tr>
  <tr>
    <td>Lesson 06</td>
    <td>Operators and Expressions</td>
    <td>Page 32</td>
  </tr>
  <tr>
    <td>Lesson 07</td>
    <td>Strings</td>
    <td>Page 40</td>
  </tr>
  <tr>
    <td>Lesson 08</td>
    <td>Conditionals</td>
    <td>Page 48</td>
  </tr>
  <tr>
    <td>Lesson 09</td>
    <td>Loops</td>
    <td>Page 56</td>
  </tr>
  <tr>
    <td>Lesson 10</td>
    <td>Arrays</td>
    <td>Page 64</td>
  </tr>
  <tr>
    <td>Lesson 11</td>
    <td>Methods</td>
    <td>Page 72</td>
  </tr>
  <tr>
    <td>Lesson 12</td>
    <td>Introduction to OOP</td>
    <td>Page 80</td>
  </tr>
  <tr>
    <td>Lesson 13</td>
    <td>Access Modifiers and Constructors</td>
    <td>Page 90</td>
  </tr>
  <tr>
    <td>Lesson 14</td>
    <td>Inheritance</td>
    <td>Page 98</td>
  </tr>
  <tr>
    <td>Lesson 15</td>
    <td>Packages</td>
    <td>Page 106</td>
  </tr>
  <tr>
    <td>Lesson 16</td>
    <td>Multithreading</td>
    <td>Page 114</td>
  </tr>
  <tr>
    <td>Lesson 17</td>
    <td>Errors and Exceptions</td>
    <td>Page 122</td>
  </tr>
  <tr>
    <td>Lesson 18</td>
    <td>List</td>
    <td>Page 130</td>
  </tr>
  <tr>
    <td>Lesson 19</td>
    <td>Abstract Classes and Interfaces</td>
    <td>Page 138</td>
  </tr>
  <tr>
    <td>Lesson 20</td>
    <td>ArrayList, LinkedList, HashMap, and Stack</td>
    <td>Page 146</td>
  </tr>
</table>

  </page>
  <br>
  <page>
    <h2>Disclaimer</h2>
    
    The book, "<b>Java for Android Explorers: A Beginner's Handbook</b>" written by Nader Mahbub Khan, aims to provide informative and educational content. However, it is important to note that programming concepts, languages, and technologies are subject to continuous evolution. The information presented in this book is based on the author's knowledge.
    Every effort has been made to ensure the accuracy and reliability of the information provided. However, the author and the publisher make no warranties or guarantees, either expressed or implied, regarding the completeness, accuracy, or applicability of the content. Readers should be aware that the information may not be suitable for all circumstances or individuals.
      
    The examples, code snippets, and programming practices discussed in this book are intended as learning tools and references. Readers are encouraged to exercise caution and consult additional resources, official documentation, and experienced professionals in the field when applying the concepts to real-world projects.
      
    Remember, you have the potential to achieve great things. Trust in yourself and believe that you can overcome any programming challenge. This book is designed to empower you on your journey to becoming a proficient Java and Android developer.
      
    The author and the publisher are here to support and guide you, but ultimately, you are responsible for your own growth and success. Embrace the learning process, be persistent, and don't be afraid to make mistakes. Every step you take in mastering Java for Android development brings you closer to reaching your goals.
      
    While the path of programming may have its challenges, it also offers tremendous opportunities for creativity and problem-solving. Embrace the joy of coding and let your imagination soar as you develop innovative applications for the Android platform.
      
    Please bear in mind that programming is an ever-evolving field, and new best practices, techniques, and technologies may emerge after the publication of this book. Stay curious and keep up with the latest developments. You have the ability to adapt and grow as the programming landscape evolves.
      
    By reading this book, readers acknowledge and accept the terms and conditions stated in this disclaimer. The author and the publisher disclaim any responsibility for any consequences that may arise from the use of the information provided in this book.
      
  <b> Always seek professional advice, trust in yourself, and believe that <i>you can achieve greatness through your dedication and passion for programming</i>.</b>
  </page>

  <!---page 01---->
  <br><br>
  <page>
    <h2>Lesson 01: Intro into Java</h2>
    Java is a high-level, object-oriented programming language widely used for developing robust and scalable applications. It was created by James Gosling and his team at Sun Microsystems in the mid-1990s. Java offers a platform-independent approach, allowing programs to run on various operating systems and devices. Its syntax is clean and readable, making it easy to learn and understand. Java supports automatic memory management through garbage collection, relieving developers from manual memory management tasks. It provides a vast standard library and extensive community support, enabling developers to leverage existing code and resources. Java's key features include platform independence, strong type checking, exception handling, multithreading, and support for networked and distributed computing. Its versatility has made it a popular choice for diverse applications, from enterprise software development to mobile and web application development. Presently, Java has a thriving community of millions of developers and has firmly established itself as a fundamental programming language for  <strong>web development, mobile applications, desktop applications, and emerging fields such as Artificial Intelligence and the Internet of Things (IoT). </strong>Exploring Java's rich history provides a broader perspective on its extraordinary journey. With its strong foundation, Java continues to pave the way for significant technological advancements and undoubtedly holds a pivotal role in shaping the future of programming.
   
  </page>
  
  <!-----page 2---->
  <br></br>
  <page>
    <h2>Lesson 02: How does Java works? ðŸ™„</h2>
    <ol>
      <li><strong>Firstly,</strong> the Java source code is compiled into bytecode using the Java compiler.</li>
      <li><strong>Next,</strong> the bytecode is loaded into the <b>Java Virtual Machine (JVM)</b>.</li>
      <li><strong>After that,</strong> the bytecode is verified for security and integrity.</li>
      <li><strong>Then,</strong> the runtime environment is prepared, and memory is allocated.</li>
      <li><strong>Subsequently,</strong> the bytecode is interpreted or <strong>JIT compiled</strong> for execution.</li>
      <li><strong>Next,</strong> the bytecode is executed, following the program's control flow.</li>
      <li><strong>Additionally,</strong> memory is managed by allocating and deallocating objects.</li>
      <li><strong>Furthermore,</strong> exceptions are handled during execution.</li>
      <li><strong>Lastly,</strong> the program is terminated, and allocated resources are released.</li>
    </ol>
    
    In a nutshell, <strong>firstly</strong>, the Java source code is compiled into bytecode, which is then <strong>loaded into the JVM</strong>. <strong>After that</strong>, the bytecode is verified, the runtime environment is prepared, and memory is allocated. <strong>Subsequently</strong>, the bytecode is executed, <strong>JIT compilation</strong> is performed if applicable, and <strong>memory management</strong> takes place. <strong>Furthermore</strong>, exceptions are handled, and <strong>lastly</strong>, the program is terminated, releasing allocated resources.
  </page>
  
  <!----page 3----->
  <br></br>
  <page>
    <h2>Lesson 03: Basic structure of a Java program</h2>
    <p>A Java program consists of a specific structure that provides the foundation for its execution. Let's explore the basic components:</p>
    <pre>
      <code class="language-java">
public class HelloWorld {
    public static void main(String[] args) {
        // This is the entry point of the program
        // It is a special method that gets executed when the program starts
        
        // Print "Hello, World!" to the console
        System.out.println("Hello, World!");
        // The above line outputs the text within the double quotes
        
        // Comments are used to provide explanations and make the code more readable
        // They are ignored by the compiler and do not affect the program's functionality
    }
}

      </code>
    </pre>
    <p>In the code,</p>
<ol>
    <li><code>public class HelloWorld:</code> Declares a class named <code>HelloWorld</code>. The <code>public</code> keyword denotes that the class is accessible from other classes.</li>
    <li><code>public static void main(String[] args):</code> Defines the <code>main</code> method, which is the entry point of the program. It has a <code>void</code> return type, meaning it doesn't return any value. It takes an array of <code>String</code> arguments as a parameter, commonly referred to as <code>args</code>.</li>
    <li><code>System.out.println("Hello, World!");</code>: Prints the string "Hello, World!" to the console. The <code>System.out.println</code> method is used to output text followed by a newline character.</li>
</ol>


<p>Basically, we need to implement these basic stuffs while writting a java program: </p>
<p><strong>Class Declaration:</strong> Every Java program starts with a class declaration. The <code>class</code> keyword is used to define a class, which serves as a blueprint for objects. It encapsulates data and methods within its scope.</p>

<p><strong>Main Method:</strong> Within the class, there is a special method called the <code>main</code> method. It acts as an entry point for the program's execution. It has a specific signature (<code>public static void main(String[] args)</code>) and serves as the starting point of the program.</p>

<p><strong>Statements and Expressions:</strong> Inside the main method, you can include statements and expressions. Statements perform actions, such as variable declarations, method calls, or control flow constructs like loops and conditionals. Expressions, on the other hand, evaluate to a value and can be used within statements or other expressions.</p>

<p><strong>Comments:</strong> Comments are essential for code documentation and understanding. They provide explanatory text that is ignored by the compiler. Java supports single-line comments (using <code>//</code>) and multi-line comments (using <code>/* */</code>).</p>

<p><strong>Package and Import Statements:</strong> Java programs can be organized into packages to avoid naming conflicts. The <code>package</code> statement specifies the package in which the class resides. Additionally, <code>import</code> statements allow you to include external classes or packages that are required by your program.</p>

<p><strong>Compiling and Running:</strong> Once the Java source code is written, it needs to be compiled into bytecode using the Java compiler. The resulting bytecode can then be executed by the Java Virtual Machine (JVM) to produce the desired output.</p>

<p><strong>Errors and Exceptions:</strong> During compilation or execution, errors and exceptions may occur. Compilation errors highlight issues with the code, such as syntax errors or type mismatches. Exceptions, on the other hand, occur during program execution due to unforeseen circumstances, such as input/output failures or null references. Proper error handling and exception management are crucial for robust programs.</p>

<p><strong>Conclusion:</strong> Understanding the basic structure of a Java program is essential for writing and executing Java code successfully. By following this structure and leveraging the power of classes, methods, statements, and expressions, you can create functional and efficient Java programs.</p>


<h2>Why and When 'public' class ??</h2>
<p>In Java, the <code>public</code> keyword is used to declare the accessibility or visibility of a class, method, or field. When you declare a class with the <code>public</code> keyword, it means that the class can be accessed and used by any other class or code within the same project or package, as well as from other projects or packages.</p>

<p>There are a few scenarios where it is appropriate to use the <code>public</code> keyword when declaring a class:</p>

<ol>
  <li>Creating a Reusable Component: If you intend for a class to be used by other developers or projects, you would typically declare it as <code>public</code>. This allows other developers to import and use your class in their own codebase.</li>
  <li>Entry Point for Execution: In Java, the entry point for execution is the <code>main</code> method. The <code>main</code> method must be declared as <code>public static void main(String[] args)</code>, as it needs to be accessible by the Java runtime environment to start the program execution.</li>
</ol>

<p>It's important to note that not all classes need to be declared as <code>public</code>. In fact, it is considered good practice to limit the visibility of your classes, methods, and fields to only what is necessary. By default, if no access modifier is specified, Java uses package-private visibility, which means the class is accessible only within the same package.</p>

<p>When deciding whether to use the <code>public</code> keyword for a class, consider the intended use and visibility requirements. If the class is part of a public API or needs to be accessed from other packages, declaring it as <code>public</code> is appropriate. Otherwise, if the class is used internally within a package, it's generally preferable to omit the <code>public</code> keyword and rely on package-private visibility for encapsulation.</p>
  </page>
  
  <!----- page 04------>
  
  <br></br>
  <page>
 

  <h2>Lesson 04: Datatypes, Variable, Keywords, Literals and Comments </h2>
  
  <p>Data types define the type and size of values that can be stored in variables. Java has two categories of data types: primitive and non-primitive types. Primitive types include integers, floating-point numbers, characters, booleans, etc., while non-primitive types include objects and arrays.</p>
  
  <table class="tablec">
    <thead>
      <tr>
        <th rowspan="2">Category</th>
        <th rowspan="2">Data Types</th>
        <th rowspan="2">Bits in Memory</th>
        <th colspan="1">Example of Storeable Data</th>
        <th rowspan="2">Range</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="8"><strong>Primitive Types</strong></td>
        <td>byte</td>
        <td>8</td>
        <td>127</td>
        <td>-128 to 127</td>
      </tr>
      <tr>
        <td>short</td>
        <td>16</td>
        <td>32000</td>
        <td>-32,768 to 32,767</td>
      </tr>
      <tr>
        <td>int</td>
        <td>32</td>
        <td>1000000</td>
        <td>-2,147,483,648 to 2,147,483,647</td>
      </tr>
      <tr>
        <td>long</td>
        <td>64</td>
        <td>9999999999L</td>
        <td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
      </tr>
      <tr>
        <td>float</td>
        <td>32</td>
        <td>3.14f</td>
        <td>Approximately -3.4E38 to 3.4E38</td>
      </tr>
      <tr>
        <td>double</td>
        <td>64</td>
        <td>3.14159</td>
        <td>Approximately -1.7E308 to 1.7E308</td>
      </tr>
      <tr>
        <td>char</td>
        <td>16</td>
        <td>'A'</td>
        <td>0 to 65,535</td>
      </tr>
      <tr>
        <td>boolean</td>
        <td>1 (usually stored as 8 bits)</td>
        <td>true</td>
        <td>true or false</td>
      </tr>
      <tr>
        <td rowspan="3"><strong>Non-Primitive Types</strong></td>
        <td>classes</td>
        <td>Depends on variable</td>
        <td>-</td>
           <td rowspan=3>N/A</td>
      </tr>
      <tr>
        <td>interfaces</td>
        <td>Depends on variable</td>
        <td>-</td>
      </tr>
      <tr>
        <td>arrays</td>
        <td>Depends on variable</td>
        <td>-</td>
      </tr>
    </tbody>
  </table>
  



   <h2>Variables</h2>
  <p>In Java, a variable is a named storage location that holds a value. It allows you to store and manipulate data in your programs.</p>
  <p>To declare a variable in Java, you need to specify its data type followed by the variable name. Here's the general syntax:</p>

<pre><code class="language-java">data_type variable_name;
</code></pre>

  <strong>The rules for naming variables are:</strong>
  <ul>
    <li>Variable names must start with a letter (A-Z or a-z), an underscore (<code>_</code>), or a dollar sign (<code>$</code>).</li>
    <li>After the initial character, variable names can contain letters, digits (0-9), underscores, or dollar signs.</li>
    <li>Variable names are case-sensitive, so <code>myVariable</code> and <code>myvariable</code> are different.</li>
    <li>Java keywords cannot be used as variable names.</li>
    <li>Choose meaningful and descriptive names for your variables to improve code readability.</li>
  </ul>
<p>Let's see an example of declaring different types of variables in Java:</p>

<pre><code class="language-java">int age; // declaring an integer variable named age
double salary; // declaring a double variable named salary
boolean isStudent; // declaring a boolean variable named isStudent
String name; // declaring a String variable named name
</code></pre>

<p>You can also initialize a variable at the time of declaration by assigning a value to it:</p>

<pre><code class="language-java">int score = 100; // declaring and initializing an integer variable named score with a value of 100
double pi = 3.14; // declaring and initializing a double variable named pi with a value of 3.14
boolean isEmployed = true; // declaring and initializing a boolean variable named isEmployed with a value of true
String message = "Hello, world!"; // declaring and initializing a String variable named message with a value of "Hello, world!"
</code></pre>


<p>Furthermore, if you want to declare multiple variables of the same type, you can separate them with commas:</p>

<pre><code class="language-java">int x, y, z; // declaring three integer variables named x, y, and z
</code></pre>

<b>Always provide an appropriate data type based on the type of values you want to store in the variable.</b>


  <h2>Keywords</h2>
  <p><strong>Keywords are reserved words that have a predefined meaning in the Java language. </strong>They cannot be used as variable names or other identifiers. Examples of keywords include <code>class</code>, <code>public</code>, <code>static</code>, <code>void</code>, <code>if</code>, <code>for</code>, etc.</p>

  <h2>Literals</h2>
  <p><strong>Literals are fixed values those are directly written in your code.</strong> They represent specific values of different data types. For example, <code>42</code> is an integer literal, <code>3.14</code> is a floating-point literal, <code>'A'</code> is a character literal, and <code>true</code> is a boolean literal.</p>

<h2>Comments</h2>
<p><strong>Comments in Java are used to add explanatory text within the source code. </strong>They are not executed by the compiler and do not affect the program's functionality. Comments serve as a way to provide information about the code, make it more readable, and document important details for other developers or yourself in the future.</p>

<strong>Java supports two types of comments:</strong>

<ol>
    <li>
        <strong>Single-line comments:</strong>
        <p>Single-line comments start with two forward slashes (<code>//</code>). Anything written after the <code>//</code> on the same line is considered a comment and is ignored by the compiler. Single-line comments are typically used for short explanations or clarifications.</p>
        <pre><code class="language-java">// This is a single-line comment
int x = 5; // Initializing variable x with the value 5</code></pre>
    </li>
    <li>
        <strong>Multi-line comments:</strong>
        <p>Multi-line comments, also known as block comments, are used for longer comments that span multiple lines. They start with <code>/*</code> and end with <code>*/</code>. Everything between these delimiters is treated as a comment and is not executed by the compiler. Multi-line comments are often used for documenting classes, methods, or providing more detailed explanations.</p>
        <pre><code class="language-java">/*
* This is a multi-line comment.
* It can span multiple lines.
* Here, we are defining a method to calculate the sum of two numbers.
*/
public int sum(int a, int b) {
return a + b;
}</code></pre>
    </li>
</ol>

<p>Comments are useful for various purposes, such as:</p>

<ul>
    <li>Providing an overview of the code's purpose.</li>
    <li>Explaining complex logic or algorithms.</li>
    <li>Documenting assumptions or constraints.</li>
    <li>Describing inputs, outputs, and side effects of methods.</li>
    <li>Adding reminders or to-do notes.</li>
</ul>
<table>
  <tr>
    <td><h2>Exercise: 01</h2>
      <ol>
        <li>Write a program to declare and initialize variables of different data types (int, double, boolean, String) and display their values.</li>
        <li>Write a program to calculate the area of a rectangle given the length and width as input from the user. Display the result.</li>
        <li>Write a program to convert temperature from Celsius to Fahrenheit. Take the temperature in Celsius as input from the user and display the result in Fahrenheit.</li>
        <li>Write a program to check if a given number is even or odd. Take an integer as input from the user and display whether it is even or odd.</li>
        <li>Write a program to concatenate two strings and display the concatenated string. Take two strings as input from the user and display the result.</li>
      </ol>
    </td>
  </tr>
</table>
  </page>
  
  <!---page--->
  <br></br>
  <page>
    <h2>Lesson 05: Read input from keyboard</h2>

    <pre>
      <code class="language-java">
        import java.util.Scanner;

        public class UserInputExample {
            public static void main(String[] args) {
                // Step 1: Import the Scanner class.
                Scanner scanner = new Scanner(System.in);
                
                // Step 3: Prompt the user for input.
                System.out.print("Enter an integer: ");
                
                // Step 4: Read the input.
                int userInput = scanner.nextInt();
                
                // Step 5: Store the input in a variable.
                int processedInput = userInput * 2;
                
                // Step 7: Display the results or perform further actions.
                System.out.println("The processed input is: " + processedInput);
                
                // Step 8: Handle exceptions (optional).
                try {
                    // Additional code that may throw exceptions.
                } catch (InputMismatchException e) {
                    System.out.println("Invalid input. Please enter an integer.");
                } catch (NoSuchElementException e) {
                    System.out.println("Input not found. Please try again.");
                }
                
                // Step 9: Close the Scanner object (optional).
                scanner.close();
            }
        }
        
      </code>
    </pre>
      <p><strong>Step 1:</strong> Import the Scanner class.</p>
      <p>- The Scanner class, located in the java.util package, needs to be imported into the Java program to use its functionalities.</p>
    
      <p><strong>Step 2:</strong> Create a Scanner object.</p>
      <p>- A new Scanner object is created by using the new Scanner(System.in) constructor. This object will be used to read input from the keyboard.</p>
    
      <p><strong>Step 3:</strong> Prompt the user for input.</p>
      <p>- Display a message to the user, asking them to enter the desired input. This serves as a prompt, providing guidance on what type of input is expected.</p>
    
      <p><strong>Step 4:</strong> Read the input.</p>
      <p>- Use the appropriate method from the Scanner object to read the input provided by the user. For example, if expecting an integer, use the nextInt() method.</p>
    
      <p><strong>Step 5:</strong> Store the input in a variable.</p>
      <p>- Assign the input read from the keyboard to a variable of the appropriate data type. This allows the program to store and manipulate the user's input.</p>
    
      <p><strong>Step 6:</strong> Process the input as needed.</p>
      <p>- Utilize the stored input in your program's logic. Perform any necessary calculations, comparisons, or operations based on the user's input.</p>
    
      <p><strong>Step 7:</strong> Display the results or perform further actions.</p>
      <p>- Output the processed input or use it to perform additional actions within the program. This may involve printing the results to the console, interacting with other parts of the program, or displaying feedback to the user.</p>
    
      <p><strong>Step 8:</strong> Handle exceptions (optional).</p>
      <p>- Implement exception handling to deal with potential errors or unexpected input. This ensures that the program gracefully handles exceptions such as InputMismatchException or NoSuchElementException.</p>
    
      <p>So, by following the points stated above, we can take input from our user in Java</p>
      
  
      <table><td>    <h2>Exercise: 02</h2><ol><li>Write a program in Java to sum three numbers.</li>
      <li>Write a program that takes as input the user's name and greets them with the phrase "Have a great day!"</li></ol></td></table>
   
  </page>
  
  <!---page----->
  <br></br>
  <page>
    <h2>Lesson 06: Operators and Expressions</h2>
Including Java, in all of the programming languages, operators are essential tools that enable us to perform various tasks or manipulate data by applying them to variables and the values they hold.
<br></br>

<br><br>
  <table>
    <tr>
      <th>Operator Category</th>
      <th>Operator</th>
      <th>Description</th>
      <th>Example Code</th>
    </tr>
    <tr>
      <td rowspan="7">Arithmetic</td>
      <td>+</td>
      <td>Addition</td>
      <td><code>int sum = num1 + num2;</code></td>
    </tr>
    <tr>
      <td>-</td>
      <td>Subtraction</td>
      <td><code>int difference = num1 - num2;</code></td>
    </tr>
    <tr>
      <td>*</td>
      <td>Multiplication</td>
      <td><code>int product = num1 * num2;</code></td>
    </tr>
    <tr>
      <td>/</td>
      <td>Division</td>
      <td><code>double quotient = num1 / num2;</code></td>
    </tr>
    <tr>
      <td>%</td>
      <td>Modulus</td>
      <td><code>int remainder = num1 % num2;</code></td>
    </tr>
    <tr>
      <td>++</td>
      <td>Increment</td>
      <td><code>num++;</code></td>
    </tr>
    <tr>
      <td>--</td>
      <td>Decrement</td>
      <td><code>num--;</code></td>
    </tr>
    <tr>
      <td rowspan="2">Assignment</td>
      <td>=</td>
      <td>Assignment</td>
      <td><code>int x = 5;</code></td>
    </tr>
    <tr>
      <td>+=</td>
      <td>Addition Assignment</td>
      <td><code>x += 2;</code></td>
    </tr>
    <tr>
      <td rowspan="3">Comparison</td>
      <td>==</td>
      <td>Equal to</td>
      <td><code>if (x == y)</code></td>

    </tr>
    <tr>
      <td>>=</td>
      <td>Greater than or equal to</td>
      <td><code>if (x >= y)</code></td>
    </tr>
    <tr>
      <td><=</td>
      <td>Less than or equal to</td>
      <td><code>if (x <= y)</code></td>
    </tr>
    <tr>
      <td rowspan="3">Logical</td>
      <td>&&</td>
      <td>Logical AND</td>
      <td><code>if (x > 0 && x < 10)</code></td>
    </tr>
    <tr>
      <td>||</td>
      <td>Logical OR</td>
      <td><code>if (x > 0 || y > 0)</code></td>
    </tr>
    <tr>
      <td>!</td>
      <td>Logical NOT</td>
      <td><code>if (!isTrue)</code></td>
    </tr>
    <tr>
      <td rowspan="2">Bitwise</td>
      <td>&</td>
      <td>Bitwise AND</td>
      <td><code>int result = num1 & num2;</code></td>
    </tr>
    <tr>
      <td>|</td>
      <td>Bitwise OR</td>
      <td><code>int result = num1 | num2;</code></td>
    </tr>
  </table>
  
  <br></br>
  <table>
  <tr>
    <td colspan=5 class="n"><b>5+6=11</b></td>
  </tr>
  <tr>
    <td class="n">5</td>
    <td class="n">+</td>
    <td class="n">6</td>
    <td class="n">=</td>
    <td class="n">11</td>
  </tr>
    <tr>
      <th>Operand</th>
      <th>Operator</th>
      <th>Operand</th>
      <th>Relational Symbol</th>
      <th>Result</th>
    </tr>
</table>

</div>
<br></br>
<h2>Precedence</h2>
<p>
  In Java, the concept of <strong>precedence</strong> refers to the order in which operators are evaluated in an expression.
  Each operator in Java has a specific precedence level, which determines how expressions are evaluated.
  The precedence rules ensure that expressions are evaluated in a predictable and consistent manner.
</p>

<p>
  Operators with higher precedence are evaluated <strong>before</strong> operators with lower precedence.
  Java follows the <strong>BODMAS</strong> rule, which stands for:
  <strong>Brackets, Orders (i.e., Exponents and Roots), Division and Multiplication, Addition and Subtraction</strong>.
  This rule determines the order in which operations are performed within an expression.
  For example, in the expression <code>2 + 3 * 4</code>, the multiplication (<code>3 * 4</code>) is performed before the addition (<code>2 + 12</code>),
  following the BODMAS rule, resulting in the final value of <strong>14</strong>.
</p>

<p>
  Here are some common precedence rules in Java:
</p>

<ol>
  <li>
    <strong>Parentheses:</strong> Expressions within parentheses are evaluated first.
    They take the highest precedence. For example, <code>(2 + 3) * 4</code> will be evaluated as <code>5 * 4</code>,
    resulting in <strong>20</strong>.
  </li>
  <li>
    <strong>Unary operators:</strong> Unary operators, such as <code>-</code> (negation) and <code>++</code> (increment),
    have higher precedence than most other operators. For example, <code>-5 * 2</code> will be evaluated as
    <code>(-5) * 2</code>, resulting in <strong>-10</strong>.
  </li>
  <li>
    <strong>Multiplicative and additive operators:</strong> Multiplication (<code>*</code>), division (<code>/</code>),
    and modulo (<code>%</code>) operators have higher precedence than addition (<code>+</code>) and subtraction (<code>-</code>)
    operators. For example, <code>2 + 3 * 4</code> will be evaluated as <code>2 + (3 * 4)</code>,
    following the BODMAS rule, resulting in <strong>14</strong>.
  </li>
  <li>
    <strong>Relational operators:</strong> Relational operators, such as <code>&lt;</code>, <code>&gt;</code>,
    <code>&lt;=</code>, and <code>&gt;=</code>, are used for comparisons. They have lower precedence than arithmetic operators.
    For example, <code>2 + 3 &lt; 5</code> will be evaluated as <code>(2 + 3) &lt; 5</code>,
    resulting in <strong>true</strong>.
  </li>
  <li>
    <strong>Logical operators:</strong> Logical operators, such as <code>&amp;&amp;</code> (logical AND) and
    <code>||</code> (logical OR), have lower precedence than relational operators.
    For example, <code>2 + 3 &lt; 5 || 6 &gt;= 7</code> will be evaluated as
    <code>(2 + 3) &lt; 5 || 6 &gt;= 7</code>, resulting in <strong>true</strong>.
  </li>
</ol>

<p>
  It's important to understand precedence rules and follow the BODMAS rule to write correct and meaningful expressions in Java.
  If needed, parentheses can be used to override the default precedence and explicitly specify the desired evaluation order.
</p>

<h2>Associativity of operators</h2>

<p>
  <strong>Associativity</strong> in Java refers to the way operators with the same precedence are grouped and evaluated in an expression.
  It determines the order in which operators are processed when they appear together.
</p>

<ol>
  <li>
    <strong>Left Associativity:</strong>
    Operators with left associativity are evaluated from left to right.
    This means that when multiple operators with the same precedence are used consecutively, the operation is performed from the leftmost operator to the right.
    <br /><br />
    Example 1:
    <code>
      int result = 10 - 3 - 2;
    </code>
    <br />
    In this example, the subtraction operator <code>-</code> has left associativity.
    The expression is evaluated as <code>(10 - 3) - 2</code>, resulting in <strong>5</strong>.
    <br /><br />
    Example 2:
    <code>
      int result = 20 / 4 / 2;
    </code>
    <br />
    Here, the division operator <code>/</code> has left associativity.
    The expression is evaluated as <code>(20 / 4) / 2</code>, resulting in <strong>2</strong>.
  </li>
  <li>
    <strong>Right Associativity:</strong>
    Operators with right associativity are evaluated from right to left.
    When multiple operators with right associativity appear in an expression, the evaluation starts from the rightmost operator and proceeds to the left.
    <br /><br />
    Example 1:
    <code>
      int result = 2 ^ 3 ^ 4;
    </code>
    <br />
    The bitwise XOR operator <code>^</code> has right associativity.
    The expression is evaluated as <code>2 ^ (3 ^ 4)</code>, resulting in <strong>5</strong>.
    <br /><br />
    Example 2:
    <code>
      boolean result = true ? false : true ? true : false;
    </code>
    <br />
    The ternary conditional operator <code>? :</code> has right associativity.
    The expression is evaluated as <code>true ? false : (true ? true : false)</code>, resulting in <strong>false</strong>.
  </li>
</ol>

<p>
  The associativity of an operator is essential in determining the order of evaluation when operators with the same precedence appear together.
  It ensures that expressions are evaluated consistently and in accordance with the rules defined by the language.
</p>

<p>
  Understanding the associativity of operators is important when writing complex expressions in Java to ensure the desired results.
</p>
<br><br>
<table>
  <td>
    <h2>Exercise: 03</h2>
    <ol>
      <li>Determine the result of the following experession: <br><code>double x=7/4 * 9/2;</code></li>
      <li> Write the following expression in a java program: v<sup>2</sup>=u<sup>2</sup>+2gh</li>
    </ol>
  </td>
</table>
  </page>
  <!------page-->
  <br></br>
  <page>
    <h2>Lesson 07: Strings</h2>
    In Java, a string is a sequence of characters. It is a data type that represents text and is enclosed in double quotes ". <strong>String</strong> is a class but it can be used like a datatype. <strong>String is immutable in java</strong>. That means that once a string is created in Java, <b>it's value cannot be modified</b>. In other words, you cannot change individual characters within a string. If you need to modify a string, you create a new string object with the desired changes.
  You can declare a String in various way in Java. for example:
  <br>
  <pre>
    <code class="language-java">
String name;
name=new String("Nader");
  </pre>
  </code>
  or
  <pre>
        <code class="language-java">
String name="Nader";
</code>
  </pre>
  <table>
  <tr>
    <td class="n">String</td>   <td class="n">name</td>    <td class="n">=</td>    <td class="n">"</td>    <td class="n">Nader</td>    <td class="n">"</td>    <td class="n">;</td>
  </tr>
  <tr>
    <td><small>Datatype</small></td>    <td><small>Reference/Identifier</small></td>    <td><small>Assign Mark</small></td>    <td><small>"</small></td>    <td><small>String Value</small></td>    <td><small>"</small></td>    <td><small>Line Ending Semicolon</small></td>
  </tr>
  </table>

  <br>
  <center>
  <table>
    <tr>
      <th>Method</th>
      <th>Description</th>
      <th>Line Break</th>
      <th>Formatting</th>
    </tr>
    <tr>
      <td><code>System.out.print()</code></td>
      <td>Prints the output without a line break</td>
      <td>No</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>System.out.println()</code></td>
      <td>Prints the output with a line break at the end</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>System.out.printf()</code></td>
      <td>Prints the output with formatting options</td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><code>String.format()</code></td>
      <td>Returns a formatted string without printing it</td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>
</center>
  <br>
  <table>
   <tr><td><h2>Format Specifier</h2><center><h4>System.out.printf("<font color="gray">Format Specifier</font>",variable);</h4></center></td></tr>
   <tr> <td> <ul>
    <li><code>%d</code> - Integer:  - Formats an integer value.<br><code>System.out.printf("Value: %d", num);</code><br></li>
    <li><code>%f</code> - Floating-point:  - Formats a floating-point value.<br><code>System.out.printf("Value: %f", num);</code><br></li>
    <li><code>%c</code> - Character: - Formats a character value.<br><code>System.out.printf("Value: %c", ch);</code><br></li>
    <li><code>%s</code> - String:  - Formats a string value.<br><code>System.out.printf("Value: %s", str);</code><br></li>
  </ul></td></tr>
  </table>
 
 <br><br>
 <p>
In Java, strings are represented as objects that represent a sequence of characters.
  They have a lot of useful methods that allow strings to be manipulated and worked with.
  Here are some commonly used string methods explained in easy language:
</p>
 <table>
    <tr>
    <td></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td></td>
    </tr><tr><td>String name="</td><td>N</td><td>a</td><td>d</td><td>e</td><td>r</td><td>;</td></tr></table>
<!---here---->
<ol>
  <li><strong>length()</strong>: This method returns the length of a string, which is the number of characters it contains. For example:</li>
  <pre><code>
String name = "Nader";
int length = name.length(); // length will be 5
  </code></pre>

  <li><strong>charAt(index)</strong>: This method returns the character at a specified index in a string. The index starts from 0. For example:</li>
  <pre><code>
String name = "Nader";
char character = name.charAt(1); // character will be 'a'
  </code></pre>

  <li><strong>substring(startIndex, endIndex)</strong>: This method extracts a portion of a string, starting from the startIndex (inclusive) up to the endIndex (exclusive). If you omit the endIndex, it will extract until the end of the string. For example:</li>
  <pre><code class="language-java">
String name = "Nader";
String substring = name.substring(1, 4); // substring will be "ade"
  </code></pre>

  <li><strong>toUpperCase()</strong> and <strong>toLowerCase()</strong>: These methods convert a string to uppercase or lowercase, respectively. For example:</li>
  <pre><code class="language-java">
String name = "Nader";
String uppercase = name.toUpperCase(); // uppercase will be "NADER"
String lowercase = name.toLowerCase(); // lowercase will be "nader"
  </code></pre>

  <li><strong>equals(anotherString)</strong>: This method compares two strings and returns true if they are equal (have the same characters), and false otherwise. For example:</li>
  <pre><code class="language-java">
String name1 = "Nader";
String name2 = "Nader";
boolean isEqual = name1.equals(name2); // isEqual will be true
  </code></pre>

  <li><strong>startsWith(prefix)</strong> and <strong>endsWith(suffix)</strong>: These methods check if a string starts with a specified prefix or ends with a specified suffix, respectively. They return true if the condition is met, and false otherwise. For example:</li>
  <pre><code class="language-java">
String name = "Nader";
boolean startsWithNa = name.startsWith("Na"); // startsWithNa will be true
boolean endsWithEr = name.endsWith("Er"); // endsWithEr will be false
  </code></pre>
  
  <li><strong>replace(char oldChar, char newChar)</strong>: This method replaces all occurrences of a specified character with a new character in a string. For example:</li>
    <pre><code class="language-java">
String name = "Nader";
String replacedStr = str.replace('N', 'K'); // replacedStr will be "Kader"!
    </code></pre>

    <li><strong>replaceAll(String regex, String replacement)</strong>: This method replaces all occurrences of a specified regular expression with a new string in a string. For example:</li>
    <pre><code class="language-java">
String sentence = "The quick brown fox jumps over the lazy dog.";
String replacedSentence = sentence.replaceAll("fox", "cat"); // replacedSentence will be "The quick brown cat jumps over the lazy dog."
    </code></pre>
    
</ol>


<p>
  These are just a few examples of the many methods available for manipulating strings in Java.
  String methods are very useful and powerful, enabling various operations on strings to be performed with ease.
</p>
<br><br>
<h2>Escape sequence characters</h2>
<p>In Java, <strong>Escape sequence characters are special characters that are used to represent certain non-printable or special characters within a string.</strong> They are represented by a <b>backslash `\`</b> followed by a specific character. Here are some commonly used escape sequence characters in Java:</p>

<ol>
  <li><code>\"</code> - Double Quote: Used to include a double quote within a string literal. For example:</li>
  <pre><code class="language-java">
String text = "She said, \&quot;Hello!\&quot;";
  </code></pre>
  <p>Output: She said, "Hello!"</p>

  <li><code>\'</code> - Single Quote: Used to include a single quote within a string literal. For example:</li>
  <pre><code>
String text = "It's a beautiful day!";
  </code></pre>
  <p>Output: It's a beautiful day!</p>

  <li><code>\\</code> - Backslash: Used to include a backslash within a string literal. For example:</li>
  <pre><code>
String path = "C:\\Program Files\\JavaBookOfNader";
  </code></pre>
  <p>Output: C:\Program Files\JavaBookOfNader</p>

  <li><code>\n</code> - New Line: Used to insert a new line within a string. For example:</li>
  <pre><code>
String message = "Hello,\nHow are you?";
  </code></pre>
  <p>Output:</p>
  <p>Hello,</p>
  <p>How are you?</p>

  <li><code>\t</code> - Tab: Used to insert a tab character within a string. For example:</li>
  <pre><code>
String details = "Name:\tNabil\nAge:\t25";
  </code></pre>
  <p>Output:</p>
  <p>Name:    Nabil</p>
  <p>Age:     25</p>

  <li><code>\r</code> - Carriage Return: Used to return the cursor to the beginning of the current line. It is often used in combination with <code>\n</code> to represent a line break on different platforms. For example:</li>
  <pre><code>
String text = "Hello\r\nWorld";
  </code></pre>
  <p>Output:</p>
  <p>World</p>

  <li><code>\b</code> - Backspace: Used to represent the backspace control character. It moves the cursor one character back. For example:</li>
  <pre><code>
String text = "Nader Mahbub\bKhan";
  </code></pre>
  <p>Output: Nader MahbuKhan</p>
</ol>

<p>These escape sequence characters are helpful when you need to include special characters or control characters within a string literal. They allow you to represent characters that cannot be easily typed or displayed directly.</p>


<br>
<table>
  <tr>
    <td><h2>Excercise: 04</h2>
      <ol>
        <li>Write  a Java program to convert a user input string to lowercase.</li>
        <li>Write a java program to replace space with underscores</li>
        <li>Write a letter to format the following letter with <strong>escape sequence characters</strong>:<br>
        <pre>
          Dear Nader, Thanks for your awesome Java Handbook. Yours ever, &lt;your name&gt;
        </pre> </li>
      </ol>
    </td>
  </tr>
</table>
  </page>
  <br><br>
  <page>
    <h2>Lesson 08 : Conditionals</h2>
  
      In Java, conditionals are used to make decisions in your code based on certain conditions. They allow you to control the flow of your program by executing different blocks of code depending on whether a condition is true or false. Let's explore the two main types of conditionals in Java:
      <br><br>
      1. <strong>if-else statements</strong>: An <code>if-else</code> statement allows you to execute different blocks of code based on a condition. Here's the basic syntax:
      <pre><code class="language-java">
         if (condition) {
             // Code to be executed if the condition is true
         } else {
             // Code to be executed if the condition is false
         }
         </pre></code>
         The <code>condition</code> is an expression that evaluates to either <code>true</code> or <code>false</code>. If the condition is true, the code inside the <code>if</code> block will be executed. Otherwise, the code inside the <code>else</code> block (if present) will be executed.
      
         For example, let's say you want to check if a number is positive or negative:
         <pre><code class="language-java">
         int number = -5;
         if (number > 0) {
             System.out.println("The number is positive");
         } else {
             System.out.println("The number is negative");
         }
         </code></pre>
         In this case, if the <code>number</code> is greater than 0, the message "The number is positive" will be printed. Otherwise, the message "The number is negative" will be printed.
      <br><br>
      2. <strong>switch statements</strong>: A <code>switch</code> statement allows you to select one of many code blocks to be executed based on the value of a variable or an expression. Here's the basic syntax:
      <pre><code class="language-java">
         switch (expression) {
             case value1:
                 // Code to be executed if expression matches value1
                 break;
             case value2:
                 // Code to be executed if expression matches value2
                 break;
             // More case statements...
             default:
                 // Code to be executed if expression doesn't match any case
                 break;
         }
         </pre></code>
         The <code>expression</code> is evaluated, and its value is compared to the values specified in the <code>case</code> statements. If a match is found, the corresponding code block is executed. If no match is found, the code block inside the <code>default</code> statement (if present) will be executed.
      
         For example, let's say you want to perform different actions based on the day of the week:
         <pre><code class="language-java">
         int dayOfWeek = 3;
         switch (dayOfWeek) {
             case 1:
                 System.out.println("It's Monday");
                 break;
             case 2:
                 System.out.println("It's Tuesday");
                 break;
             // More case statements for other days...
             default:
                 System.out.println("Invalid day");
                 break;
         }
         </pre></code>
         In this case, if <code>dayOfWeek</code> is 3, the message "It's Tuesday" will be printed.
      
<!-------explain and or not------->
<br>
  In Java, the logical operators <code>&amp;&amp;</code> (AND), <code>||</code> (OR), and <code>!</code> (NOT) are used to combine and negate conditions in conditional statements.
  
  1. AND (<code>&amp;&amp;</code>):
  The AND operator (<code>&amp;&amp;</code>) evaluates to <code>true</code> if both of its operands are <code>true</code>, and <code>false</code> otherwise. It is commonly used when you want multiple conditions to be true for a certain action to be taken.
  
  Example:
  <pre><code class="language-java">int age = 25;
  boolean isStudent = true;
  
  if (age >= 18 &amp;&amp; isStudent) {
      System.out.println("You are eligible for a student discount.");
  }</pre></code>
  
  In this example, the condition <code>age >= 18 &amp;&amp; isStudent</code> checks if the person is both 18 years or older and a student. Only if both conditions are true, the message will be printed.
  
  2. OR (<code>||</code>):
  The OR operator (<code>||</code>) evaluates to <code>true</code> if at least one of its operands is <code>true</code>, and <code>false</code> otherwise. It is used when you want one of multiple conditions to be true for a certain action to be taken.
  
  Example:
  <pre><code class="language-java">int grade = 85;
  
  if (grade >= 90 || grade <= 60) {
      System.out.println("You passed the exam.");
  }</pre></code>
  
  In this example, the condition <code>grade >= 90 || grade <= 60</code> checks if the grade is either greater than or equal to 90 or less than or equal to 60. If either condition is true, the message will be printed.
  
  3. NOT (<code>!</code>):
  The NOT operator (<code>!</code>) negates the value of its operand. If the operand is <code>true</code>, it will be evaluated as <code>false</code>, and if the operand is <code>false</code>, it will be evaluated as <code>true</code>. It is used to invert a condition.
  
  Example:
  <pre><code class="language-java">boolean isSunny = false;
  
  if (!isSunny) {
      System.out.println("Take an umbrella with you.");
  }</pre></code>
  
  In this example, the condition <code>!isSunny</code> checks if it's not sunny. If the value of <code>isSunny</code> is <code>false</code>, the message will be printed.
  
  These logical operators can also be combined to create more complex conditions. It's important to understand their behavior and precedence when using them in conditional statements to achieve the desired logic flow.
      Conditionals are powerful constructs in Java that allow you to make decisions and control the behavior of your program based on different conditions. They enable you to write flexible and dynamic code by executing specific blocks of code depending on the evaluation of conditions.
      <br><br>
      <table>
        <td>
          <h2>Excercise: 05</h2>
          <ol>
            <li>What will be the output for this program?
              <pre><code class="language-java">
       int y=73;
        if(y==73){
          System.out.println("Correct");
        }
        else{
          System.out.println("Wrong");
        }
              </code>
            </li>
            <li>Write a program to find out if a student have passed or failed in the exam. It requires 33% of the total marks to pass. Consider the marks for only one subject of the student as input.</li>
         <li>Write a program to find out the input website link's type...<br>
        <table>
          <tr><td>.com</td><td>Commercial</td></tr>
          <tr><td>.bd</td><td>Bangladeshi</td></tr>
          <tr><td>.org</td><td>Organization</td></tr>
        </table></li>
          </ol>
        </td>
      </table>
    </page>
    <br></br>
    <page>
      <h2>Lesson 09: Loops</h2>
   <p>Sometimes we want our programs to execute a few set of instructions over and over again. For example, we may need to print numbers from 1 to 1000 or generate the multiplication table of 7. Loops make it easy for us to instruct the computer to execute a given set of instructions repeatedly.</p>
<p>Types of Loops:</p>
<p>There are <b>three</b> types of loops in Java:</p>

1. <strong>While loop: </strong>It repeatedly executes a block of code as long as a specified condition is true.
<p>Now, let's take a closer look at while loops:</p>
<strong>While loop's structure:</strong>
<pre>
  <code class="language-java">
while (condition) {
// code block to be executed
}
  </code>
</pre>
<strong>Examples:</strong>
<pre><code class="language-java">
// Example 1: Printing numbers from 1 to 10 using a while loop
int i = 1;
while (i <= 10) {
  System.out.println(i);
  i++;
}

// Example 2: Generating the multiplication table of 7 using a while loop
int number = 7;
int multiplier = 1;
while (multiplier <= 10) {
  int result = number * multiplier;
  System.out.println(number + " x " + multiplier + " = " + result);
  multiplier++;
}

</code></pre>
2. <strong>Do-while loop: </strong>It is similar to the while loop but guarantees that the code block is executed at least once, even if  condition is initially false.
<p>Now, let's move on to do-while loops:</p>
<strong>Do-while loop's structure:</strong>
<pre><code class="language-java">
do {
// code block to be executed
}
while (condition);
</code></pre>
<strong>Examples:</strong>
<pre><code class="language-java">
// Example: Calculating the sum of numbers from 1 to 10 using a do-while loop
int sum = 0;
int j = 1;
do {
  sum += j;
  j++;
} while (j <= 10);
System.out.println("Sum: " + sum);

</code></pre>
<p>A do-while loop executes the code block first and then checks the condition. It ensures that the code block is executed at least once, even if the condition is initially false. In the example above, the loop calculates the sum of numbers from 1 to 10 by repeatedly adding the value of 'j' to the 'sum' variable.</p>
<br>

3.<strong> For loop: </strong>It provides a concise way to iterate over a range of values and execute a block of code for each iteration.
<br>
Lastly, let's explore the examples of for loops:
<strong>For loop's structure:</strong>
<pre><code class="language-java">
for (one time statement; till the condition; everytime statement) {
// code block to be executed
}
</code>
</pre>
<pre><code class="language-java">
// Example: Printing even numbers from 1 to 10 using a for loop
for (int k = 2; k <= 10; k += 2) {
  System.out.println(k);
}
</code></pre>

<pre><code class="language-java">
// Example: Printing odd numbers from 1 to 10 using a for loop
for (int k = 1; k <= 10; k += 2) {
  System.out.println(k);
}
</code></pre>
<p>A for loop provides a concise way to iterate over a range of values and execute a block of code for each iteration. In the first for loop example, even numbers from 1 to 10 are printed by incrementing the value of 'k' by 2 in each iteration. In the second example, odd numbers from 1 to 10 are printed by the same mechanism.</p>
<br>


The <b>break</b> statement is used to terminate the execution of a loop prematurely. When the break statement is encountered inside a loop, the control immediately exits the loop, regardless of whether the loop condition is true or false. This allows you to forcefully stop the execution of a loop before its natural termination.
<br>
Example:
<pre>
<code class="language-java">
for (int i = 1; i &lt;= 10; i++) {
    if (i == 5) {
        break; // Terminate the loop when i is equal to 5
    }
    System.out.println(i);
}
</code></pre>
<br>
Output:
<pre>
<code class="language-java">
1
2
3
4
</code></pre>

In the example, the loop starts from 1 and continues until 10. However, when the value of <b>i</b> becomes 5, the break statement is encountered, causing the loop to terminate immediately. As a result, only the numbers 1, 2, 3, and 4 are printed.

<br><br>
The <b>continue</b> statement is used to skip the current iteration of a loop and move to the next iteration. When the continue statement is encountered inside a loop, it jumps to the next iteration, ignoring any remaining statements below the continue statement within the loop for that particular iteration.
<br>
Example:
<pre>
<code class="language-java">
for (int i = 1; i &lt;= 5; i++) {
    if (i == 3) {
        continue; // Skip the iteration when i is equal to 3
    }
    System.out.println(i);
}
</code></pre>
Output:
<pre>
<code class="language-java">
1
2
4
5
</code>
</pre>
In this example, the loop iterates from 1 to 5. However, when <b>i</b> is equal to 3, the continue statement is encountered, causing the loop to skip the current iteration. As a result, the number 3 is not printed, and the loop proceeds to the next iteration.

In a nutshell:
1. The <b>break</b> statement completely exits the loop, regardless of the loop condition.
2. The <b>continue</b> statement skips the current iteration of the loop and moves to the next iteration, bypassing any statements below the continue statement for that iteration.
<br>
<table>
  <tr>
    <td>
      <h2>Excercise: 06</h2>
      <ol>
        <li>Write a program to print the following pattern using while, do while and for loop:
        <pre><code class="language-java">
        ****
        ***
        **
        *</code></pre></li>
        <li>Write a program to sum first n-th even numbers using while, do while and for loop.</li>
        <li>Write a program to print the multiplication table of a given number in forward and reverse order.</li>
        <li>Write a program to find factorial of a number using while, do while and for loop</li>
      </ol>
    </td>
  </tr>
</table>
    </page>
    <br></br>
    <page>
      <h2>Lesson 10: Arrays</h2>
      <p>An array is a grouping of data that consists of elements of the same datatype.</p>
      <p>Imagine a Java array as a way to group items together under a single name. It's similar to having a box divided into compartments, where each compartment can hold one item. However, in Java, <b>all the items in an array must be of the same type</b>, such as numbers, text, or objects.</p>

<p>To create an array in Java, you first specify the type of items it will contain and then assign it a name. For instance, if you want to create an array to store numbers, you can do it like this:</p>

<pre><code class="language-java">
int[] numbers;
</code></pre>

<p>This line of code creates an array named "<b>numbers</b>" capable of holding integers.</p>

<p>Let's say you want to store three numbers in this array. You can assign values to the array's compartments as follows:</p>

<pre><code class="language-java">
numbers[0] = 5;
numbers[1] = 10;
numbers[2] = 15;
</code></pre>

<p>In this case, the first compartment (index 0) holds the number <b>5</b>, the second compartment (index 1) holds <b>10</b>, and the third compartment (index 2) holds <b>15</b>.</p>

<p>To access the values stored in the array, you use the index number. For example, to retrieve the value in the second compartment, you can write:</p>

<pre><code class="language-java">
int value = numbers[1];
</code></pre>

<p>The variable "<b>value</b>" will now contain the number <b>10</b>.</p>

<p>Arrays are valuable when you have a collection of related items that you want to work with as a group. They enable you to conveniently store and retrieve multiple values using index numbers.</p>

<p>It's important to remember that arrays have a fixed size, meaning you must specify the number of compartments when creating them. If you need to store more items than the initial size allows, you would need to create a new array with a larger size and copy the existing items into it.</p>

<br>
<p>
    In the following Java example, we use an array to store strings:
</p>

<pre><code class="language-java">
String[] names = new String[3];
</code></pre>

<p>
    In this illustration, we create an array called "names" specifically designed to hold strings. We specify that the array has a size of 3, indicating that it can accommodate three string values.
</p>

<pre><code class="language-java">
names[0] = "Nader";
names[1] = "Habib";
names[2] = "Sakib";
</code></pre>

<p>
    Here, we assign the strings "Nader", "Habib", and "Sakib" to the first, second, and third positions of the array, respectively.
</p>

<pre><code class="language-java">
String firstPerson = names[0];
System.out.println("The first person is: " + firstPerson);
</code></pre>

<p>
   With this code, we retrieve the value located at index 0 (which corresponds to "Nader") and print it to the console.
</p>

<pre><code class="language-java">
for (int i = 0; i &lt; names.length; i++) {
    System.out.println("Person " + i + ": " + names[i]);
}
</code></pre>

<p>
    This loop allows us to traverse the array using the index variable <code>i</code>. It prints each name alongside its corresponding index number.
</p>

<p>
    <strong>It's important to remember that in Java, array indexing starts from 0, meaning the first element is accessed at index 0, the second element at index 1, and so on.</strong>
</p>

<p>
   By utilizing arrays with strings, you can conveniently store and manipulate collections of names, words, or any other text-based data.
</p>

<br>
<p>
    <strong><u>In summary, here's how arrays work:</u></strong>
</p>

<p>
    <strong><u>Declaration and memory allocation:</u></strong> You declare an array by specifying its type and name, such as <code>int[] marks</code>, and then allocate memory for it by using the <code>new</code> keyword, like <code>marks = new int[5]</code>.
</p>

<p>
    <strong><u>Declaration and memory allocation in one line:</u></strong> Alternatively, you can combine the declaration and memory allocation into a single line, like <code>int[] marks = new int[5]</code>.
</p>

<p>
    <strong><u>Declaration, memory allocation, and initialization:</u></strong> You can declare, allocate memory, and initialize the array in one step by providing the initial values within curly braces, like <code>int[] marks = {100, 70, 80, 71, 98}</code>. This creates an array called "marks" with five elements initialized to the respective values.
</p>

<p>
    <strong><u>Array indices start from 0:</u></strong> It's important to note that array indices begin from 0 and go up to (n-1), where "n" represents the size of the array. For example, if you have an array with a size of 5, the indices will range from 0 to 4.
</p>

<p>
    In essence, arrays allow you to <strong>declare, allocate memory for, and initialize collections of values</strong>. The indices provide a way to <strong>access individual elements within the array</strong>.
</p>


 <p>
    Array length: Arrays have a <strong>length</strong> property which gives the length of the array.
</p>

<code>
marks.length</code> gives 5 if marks is a reference to an array with 5 elements.


<p>
    Displaying an Array: An array can be displayed using a for loop.
</p>

<pre><code class="language-java">
for (int i = 0; i &lt; marks.length; i++) {
    System.out.println(marks[i]);
}
</code></pre>

<p>
    <strong>Note:</strong> The line <code>System.out.println(marks[i]);</code> is responsible for array traversal as it prints the value of each element to the console.
</p>

<p>
    For each loop in Java: Array elements can also be traversed as follows:
</p>

<pre><code class="language-java">
for (int element : arr) {
    System.out.println(element);
}
</code></pre>

<p>
    This code snippet will print all the elements of the array.
</p>

<p>
    <b><u>Multidimensional Arrays: </u></b>Multidimensional arrays are arrays of arrays. Each element of a multidimensional array is an array itself. For example, in the previous example, "marks" was a one-dimensional array.
</p>

<p>
    Multidimensional 2-D Array: A 2-D array can be created as follows:
</p>

<pre><code class="language-java">
int[][] flats = new int[2][3];
</code></pre>

<p>
    We can add elements to this array as follows:
</p>

<pre><code class="language-java">
flats[0][0] = 100;
flats[0][1] = 99;
flats[0][2] = 98;
flats[1][0] = 97;
flats[1][1] = 96;
flats[1][2] = 95;
</code></pre>

<p>
    This 2-D array can be visualized as follows:
</p>

<table>
    <thead>
        <tr>
            <th>Row 0</th>
            <th>Col 0</th>
            <th>Col 1</th>
            <th>Col 2</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Row 1</th>
            <td>100</td>
            <td>99</td>
            <td>98</td>
        </tr>
        <tr>
            <th>Row 2</th>
            <td>97</td>
            <td>96</td>
            <td>95</td>
        </tr>
    </tbody>
</table>

<p>
    Similarly, a 3-D array can be created as follows:
</p>

<pre><code class="language-java">
String[][][] arr = new String[2][3][4];
</code></pre>

<h2>Calculating Array Size in Byte</h2>
<p>
    In Java, the size of an array in bytes can be calculated using the following formula:
</p>

<pre><code class="language-java">
Array size in bytes = Element size * Number of elements
</code></pre>

<p>
    To determine the element size, we need to consider the data type of the array elements. Each data type in Java has a specific size in bytes. Here are the standard sizes for common data types:
</p>

<ul>
    <li><code>boolean</code>: 1 byte</li>
    <li><code>byte</code>: 1 byte</li>
    <li><code>char</code>: 2 bytes</li>
    <li><code>short</code>: 2 bytes</li>
    <li><code>int</code>: 4 bytes</li>
    <li><code>long</code>: 8 bytes</li>
    <li><code>float</code>: 4 bytes</li>
    <li><code>double</code>: 8 bytes</li>
    <li>Object references: Typically 4 or 8 bytes (depending on the JVM architecture)</li>
</ul>

<p>
    Let's say we have an array of integers (<code>int[]</code>) with <code>n</code> elements. In this case, the element size would be 4 bytes (since <code>int</code> is 4 bytes), and the formula for calculating the array size in bytes would be:
</p>

<pre><code class="language-java">
Array size in bytes = 4 * n
</code></pre>

<p>
    Similarly, for other data types, we would use the appropriate element size in the formula.
</p>

<p>
    It's important to note that the array size in bytes only includes the space required to store the elements themselves, excluding any additional overhead or metadata associated with the array object.
</p>

<p>
    Here's an example to illustrate the calculation of the array size in bytes:
</p>

<pre><code class="language-java">
int[] numbers = new int[10];
int sizeInBytes = numbers.length * 4; // Assuming int is 4 bytes
System.out.println("Array size in bytes: " + sizeInBytes);
</code></pre>

<p>
    This code creates an integer array with 10 elements and calculates the array size in bytes by multiplying the number of elements (<code>numbers.length</code>) with the element size (4 bytes for <code>int</code>). The result is printed to the console.
</p>
<br>
<br>
<table>
  <tr>
    <td>
      
      <h2>Excercise: 07</h2>
      <ol>
        <li>Create an array of 5 floating-point numbers and calculate their sum.</li>
        <li>Write a program to check if a given integer exists in an array.</li>
        <li>Calculate the average marks from an array that contains the marks of all students in Physics, using a for-each loop.</li>
        <li>Create a Java program to add two matrices of size 2x3.</li>
        <li>Write a Java program to reverse an array.</li>
        <li>Write a Java program to find the maximum element in an array.</li>
        <li>Write a Java program to find the minimum element in a Java array.</li>
        <li>Write a Java program to determine whether an array is sorted or not.</li>
      </ol>
      
     
    </td>
  </tr>
</table>


    </page>
    <br><br>
    <page>
      <h2>Lesson 11: Methods</h2>
      <p>Sometimes, when our program becomes larger, we may want to separate the main method's logic into other methods. This can be helpful, for example, when we need to calculate the average of a pair of numbers multiple times. By using methods, we can avoid repeating the same logic, which is often referred to as "DRY" or "Don't Repeat Yourself".</p>

<p>To define a method in Java, we write a method (function) inside a class. Since Java is an Object-Oriented language, the method must be written within a class.</p>

<p>The syntax for a method is as follows:</p>

<pre><code class="language-java">
datatype name() {
    // Method body
}
</code></pre>

<p>As an example, the following method calculates the sum of two numbers and returns an integer:</p>

<pre><code class="language-java">
int mySum(int a, int b) {
    int c = a + b;
    return c;
}
</code></pre>


<p>To call a method, you can create an object of the class where the method exists and then invoke the method using the object. Here's an example:</p>

<pre><code class="language-java">ClassName objectName = new ClassName();
objectName.methodName(arguments);
</code></pre>

<p>In the above code snippet, <code>ClassName</code> is the name of the class where the method is defined, <code>objectName</code> is the name of the object created using the <code>new</code> keyword, <code>methodName</code> is the name of the method, and <code>arguments</code> are the values passed to the method.</p>

<p>For example, let's consider a class named <code>Calc</code> with a method called <code>mySum</code>:</p>

<pre><code class="language-java">Calc obj = new Calc();
int result = obj.mySum(a, b);
</code></pre>

<p>In the above code, an object <code>obj</code> of the class <code>Calc</code> is created using the <code>new</code> keyword, and then the <code>mySum</code> method is called on the <code>obj</code> object with the arguments <code>a</code> and <code>b</code>. The return value of the <code>mySum</code> method is stored in the variable <code>result</code>.</p>

<p>It's important to note that when calling a method, the values of the arguments are copied to the corresponding parameters of the method. Therefore, even if the values of <code>a</code> and <code>b</code> are modified inside the method, the values in the main method will not change.</p>

<p>Additionally, if you don't want a method to return anything, you can use <code>void</code> as the return type. In Java, the <code>static</code> keyword is used to associate a method with the class itself rather than an instance of the class. A static method is shared by all objects of the class.</p>

<p>To illustrate the process of method invocation, let's consider a method called <code>Sum</code>:</p>

<pre><code class="language-java">int Sum(int a, int b) {
    return a + b;
}
</code></pre>

<p>The method can be called like this:</p>

<pre><code class="language-java">Calc obj = new Calc();
int c = obj.Sum(2, 3);
</code></pre>

<p>In the above code, the values 2 and 3 are passed as arguments to the <code>Sum</code> method, and the result of the addition, <code>5</code>, is returned and stored in the variable <code>c</code>, which is of type <code>int</code>.</p>

<p><strong>Method Overloading:</strong></p>
<p>Two or more methods can have the same name but different parameters. Such methods are called overloaded methods.</p>
<pre><code class="language-java">
void foo()
void foo(int a) // Overloaded function for int foo(int a, int b)
</code></pre>

<p><strong>Method overloading cannot be performed by changing the return type of methods.</strong></p>

<p><strong>Variable Arguments (Varargs):</strong></p>
<p>A function with varargs can be created in Java using the following syntax:</p>
<pre><code class="language-java">
public static void foo(int... arr)
// arr is available here as int[] arr
</code></pre>
<p><em>foo</em> can be called with zero or more arguments like this:</p>
<pre><code class="language-java">
foo(7);
foo(7, 8, 9);
foo(1, 2, 7, 8, 9);
</code></pre>
<p>We can also create a function like this:</p>
<pre><code class="language-java">
public static void bar(int a, int... arr)
// Code Logic - At least one integer is required: now
</code></pre>
<p><em>bar</em> can be called as:</p>
<pre><code class="language-java">
bar(1);
bar(1, 2);
bar(1, 7, 9, 1);
</code></pre>

<p><strong>Recursion:</strong></p>
<p>A function in Java can call itself. Such calling of a function by itself is called recursion. Example: factorial of a number factorial(n) = n * factorial(n-1)</p>

<p>Example:</p>
<p>Write a program to calculate the factorial of a number in Java using recursion.</p>
<pre><code class="language-java">
public static int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n-1);
    }
}
</code></pre>
<br>
<table>
  <tr>
    <td>
      <h2>Excercise: 08</h2>
        <ol>
          <li>
            Write a Java method to display the multiplication table of a number 'n'...
          </li>
          <li>
            Write a program that utilizes functions to print the following pattern:
            <pre><code>
      *
      **
      ***
          </code></pre>
          </li>
          <li>
            Create a recursive function to calculate the sum of the first 'n' natural numbers.
          </li>
          <li>
            Write a method (function) to print the following pattern:
            <pre><code>
      *
      *
      **
          </code></pre>
          </li>
          <li>
            Implement a function to print the nth term of the Fibonacci series using recursion.
          </li>
          <li>
            Develop a function to calculate the average of a set of numbers passed as arguments.
          </li>
          <li>
            Repeat task 4 using recursion.
          </li>
          <li>
            Repeat task 2 using recursion.
          </li>
          <li>
            Write a method (function) to convert Celsius temperature into Fahrenheit.
          </li>
        </ol>
       
    </td>
  </tr>
</table>

    </page>
    <br><br>
    <page>
      <h2>Lesson 12: Introduction to OOP</h2>
      <strong>Object-oriented programming</strong> (OOP) aims to associate code instructions with real-world concepts, resulting in shorter and more understandable code.
      <br>
      <b><u>Object-Oriented Programming: </u></b>Solving problems by creating objects is one of the most popular approaches in programming, known as Object-Oriented Programming.
      <br>
      <b><u>What is DRY: </u></b>DRY stands for "Don't Repeat Yourself" and emphasizes code reusability.
      <br>
      <b><u>Class: </u></b>A class serves as a blueprint for creating objects. For example, a GST Application Form is filled by a student, representing an application specific to that student. Here, you can say that GST Application form is a <b>Class</b> (template), When a student filling up that form, the event can be called <b>Object Instantiation</b>. After the form fillup is done, it (the form filled with the student's details) can be same as like as <b>Object</b>.
      
      
      <br>
      Mainly a <code>Class</code> contains information to create a valid <code>object</code>.
      <br>
      <b><u>Object:</u></b> An object is an instance of a class. When a class is defined, it establishes a template (containing information). <b>Memory allocation occurs only after object instantiation.</b>
      <br>
      To model a problem in OOPs, we follow these steps:
    <ul>
        <li><b>Nouns</b> &rarr; <b>Class</b></li>
        <li><b>Adjectives</b> &rarr; <b>Attributes</b></li>
        <li><b>Verbs</b> &rarr; <b>Methods</b></li>
    </ul>

    <p>For example, if we consider an Employee:</p>
    <ul>
        <li><b>Employee</b> is a <b>noun</b>, so it would be a <b>class</b>.</li>
        <li><b>Age</b>, <b>salary</b>, and other characteristics are <b>adjectives</b>, so they would be <b>attributes</b>.</li>
        <li><b>getSalary()</b>, <b>getAge()</b>, and other actions are <b>verbs</b>, so they would be <b>methods</b>.</li>
    </ul>

    <h2>OOPs Terminology:</h2>
    <ol>
        <li><b>Abstraction:</b> It involves hiding internal details and exposing only essential information. This allows us to use a phone without worrying about its manufacturing process.</li>
        <li><b>Encapsulation:</b> It refers to the act of combining different components into a single unit. For instance, a laptop encapsulates WiFi, speakers, and storage within a single box. In Java, encapsulation also enables sensitive data to be hidden from users.</li>
        <li><b>Inheritance:</b> It implements DRY (Don't Repeat Yourself)! Inheritance allows the creation of new things by deriving from existing ones. For example, a Car and a Bike can both inherit characteristics from the general concept of a Vehicle.</li>
        <li><b>Polymorphism:</b> It describes the ability of an entity to take on multiple forms. For instance, a Smartphone can be treated as a specific type of Phone or as a Calculator when required.</li>
    </ol>
<br>
    <h2>Writing a Custom Class</h2>
    <p>To create a custom class, let's consider an example of an Employee:</p>

    <pre><code class="language-java">
class Employee {
    int id; // Attribute: unique identification for the employee
    String name; // Attribute: name of the employee
}
    </code></pre>

    <p>In this example, we define a class called <code>Employee</code>. It has two attributes: <code>id</code> to represent the unique identification of the employee, and <code>name</code> to store the name of the employee.</p>

    <h2>Understanding Attributes and Methods:</h2>
    <p>In object-oriented programming, we think about real-world objects in terms of their properties (attributes) and behaviors (methods).</p>
    <p>For instance, an Employee object has attributes such as <code>id</code> and <code>name</code>, which represent its unique identification and name respectively.</p>

    <h2>Adding Methods to the Class</h2>
    <p>To enhance the functionality of the <code>Employee</code> class, we can add methods. Let's consider the following examples:</p>

    <pre><code class="language-java">
public class Employee {
    int id;
    String name;

    public int getSalary() {
        // Method: retrieves the salary of the employee
        // Code implementation goes here
    }

    public void getDetails() {
        // Method: displays the details of the employee
        // Code implementation goes here
    }
}
    </code></pre>

    <br><br>
    <table>
      <tr>
        <td>
          <h2>Excercise: 09</h2>
          Write a class...
          <ol>
  <li>
    <strong>Employee </strong>and
    <ol>
      <li>Salary (property) - <code>getSalary()</code> method returning an int</li>
      <li>Name (property) - <code>getName()</code> method returning a String</li>
      <li><code>setName()</code> method for changing the name</li>
    </ol>
  </li>
  <li>
    <strong>Cellphone </strong>and
    <ol>
      <li>Methods to print "Ringing..." and "Vibrating..."</li>
    </ol>
  </li>
  <li>
    <strong>Square </strong>and
    <ol>
      <li>Method to initialize its side</li>
      <li>Method to calculate the area</li>
      <li>Method to calculate the perimeter</li>
    </ol>
  </li>
  <li>
    <strong>Rectangle </strong> (based on Square class from question 3) and
    <ol>
      <li>Methods to initialize its sides</li>
      <li>Method to calculate the area</li>
      <li>Method to calculate the perimeter</li>
    </ol>
  </li>
  <li>
    <strong>TommyVecetti</strong> (for Rockstar Games) and
    <ol>
      <li>Method for hitting (print "Hitting")</li>
      <li>Methods for running, firing, etc.</li>
    </ol>
  </li>
  <li>
    <strong>Circle</strong> and
    <ol>
      <li>Method to initialize its radius</li>
      <li>Method to calculate the area</li>
      <li>Method to calculate the circumference</li>
    </ol>
  </li>
</ol>

        </td>
      </tr>
    </table>
    <br><br>
    <page>
<h2>Lesson 13: Access Modifiers and Constructors</h2>
Access modifiers specify the accessibility of a property/method. In Java, there are four types of access modifiers:

<ol>
  <li><b>Private: </b>The property/method is only accessible within the same class.</li>
  <li><b>Default: </b>The property/method is accessible within the same package.</li>
  <li><b>Protected: </b>The property/method is accessible within the same package and subclasses.</li>
  <li><b>Public: </b>The property/method is accessible from anywhere.</li>
</ol>

<b><u>Getters and Setters</u></b>:
Getters (accessors) =>  Returns the value of a property.<br>
Setters (mutators) => Sets/Updates the value of a existing property.

Example:
<pre>
<code class="language-java">
public class Employee {
    private int id;
    private String name;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}
</code>
</pre>
In the above example, the "id" property is declared as private, meaning it can only be accessed within the Employee class. The "name" property is also private, but it has public getter and setter methods, allowing other classes to retrieve and modify its value.
<br>
<table>
  <tr>
    <td><b>Quick Quiz</b>: Write a program to use these getters and setters from the main method.</td>
  </tr>
</table>

<h2>Constructors</h2>

 
  <p>Constructors in Java are member functions used to <b>initialize an object during its creation.</b></p>
  
 
  
  <p>In Java, a constructor is a special method that is used <b>to create and initialize objects of a class.</b> Think of a constructor as a set of instructions that are followed when you create an object from a class. It's like a recipe that tells Java how to create the object.</p>
  
  <p>When you create an object using the <code>new</code> keyword, <b>the constructor is automatically called. </b>It is responsible for <b>setting up the initial state of the object</b>, which means <b>giving values to its variables or properties.</b>
  
  <p>For example, let's say you have a class called <code>Car</code>. You can define a constructor for the <code>Car</code> class that sets the initial values of its properties, such as <code>color</code> and <code>model</code>. When you create a new <code>Car</code> object, <b>the constructor is called to initialize these properties based on the instructions you provided.</b></p>
  
  <p>Constructors are important because <b>they ensure that the object is properly initialized before you start using it</b>. They help in setting default values and preparing the object for use. Without a constructor, you might end up with an object that has undefined or incorrect values.</p>
  <!----
  Inheritance, which you mentioned earlier, also involves constructors. When you create a subclass (a class that inherits from another class), its constructor usually needs to call the constructor of the superclass first. This ensures that both the subclass-specific and superclass-specific initialization is performed correctly.
  --->
  
  <p>In a nutshell, a constructor is a <b>special method used to create and initialize objects</b>. It ensures that <b>objects are properly set up before you start using them.</b></p>
  
  <p>Here's an example that demonstrates the concept of constructors step by step:</p>

<pre><code class="language-java">// Define a class called Car
class Car {
    String color;
    String model;

    // Constructor for the Car class
    public Car(String carColor, String carModel) {
        color = carColor;
        model = carModel;
    }
}
</code></pre>

<p>In the code above:</p>

<ul>
  <li>We define a class called <code>Car</code> with two properties: <code>color</code> and <code>model</code>.</li>
  <li>Next, we create a constructor for the <code>Car</code> class. It takes two parameters: <code>carColor</code> and <code>carModel</code>.</li>
  <li>Inside the constructor, we assign the values of <code>carColor</code> and <code>carModel</code> to the corresponding properties of the <code>Car</code> object.</li>
</ul>

<p>Now, let's create an instance (object) of the <code>Car</code> class and see how the constructor works:</p>

<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        // Create a new Car object using the constructor
        Car myCar = new Car("Blue", "Sedan");

        // Access the properties of the Car object
        System.out.println("Color: " + myCar.color);
        System.out.println("Model: " + myCar.model);
    }
}
</code></pre>

<p>In the code above:</p>

<ul>
  <li>We create a new object called <code>myCar</code> of type <code>Car</code> using the <code>new</code> keyword and passing "Blue" and "Sedan" as arguments to the constructor.</li>
  <li>The constructor is called automatically, and it initializes the <code>color</code> property with "Blue" and the <code>model</code> property with "Sedan".</li>
  <li>Finally, we access the properties of the <code>myCar</code> object and print their values.</li>
</ul>

<p>Output:</p>

<pre><code>Color: Blue
Model: Sedan
</code></pre>

<p>As you can see, the constructor is responsible for initializing the object's properties with the values we provided when creating the object. It ensures that the object starts with the correct initial state.</p>


  <!--<h2>Example:</h2>
  <pre><code class="language-java">Employee e1 = new Employee();
e1.setName("Nader Mahbub Khan");</code></pre>

  <p>To create our own constructor, we have to define a method with the same name as the class.</p>

  <h2>Example:</h2>
  <pre><code class="language-java">public Employee() {
  name = "Your Name";
}</code></pre>

  <p>Constructor Overloading in Java allows us <b>to have multiple constructors with different parameters,</b> just like other methods.</p>

  <h2>Example:</h2>
  <pre><code class="language-java">public Employee(String e) {
  name = e;
}</code></pre>
---->
  <p>Note:</p>
  <ul>
    <li>Constructors can also take parameters without overloading.</li>
    <li>It is possible to have more than two overloaded constructors.</li>
  </ul>

  <table>
    <tr>
      <td>
        <b>Quick Quiz</b>: Overload the Employee constructor to initialize the salary to 32,000 Bangladeshi Taka
      </td>
    </tr>
  </table>

  <h4>Solution:</h4>
  <pre><code class="language-java">public Employee(String e, int salary) {
  name = e;
  this.salary = salary;
}</code></pre>

<br><table>
  <tr>
    <td>
      <h2>Excercise: 10</h2>
      
      
      <ol>
        <li>Write a class called "Cylinder" and implement getters and setters to set its radius and height.</li>
        <li>Using the appropriate formula, calculate the surface area and volume of a Cylinder.</li>
        <li>Write a constructor for the Cylinder class that replicates the functionality described in question 1.</li>
        <li>Overload a constructor to initialize a rectangle with a length of 4 and breadth of 5, using custom parameters.</li>
        <li>Write a class that incorporates the concepts mentioned above to calculate the surface area and volume of a sphere.</li>
      </ol>
    </td>
  </tr>
</table>
    </page>
    <br><br>
    <page>
      <h2>Lesson 14: Inheritance</h2>
  <p>Inheritance is used to inherit properties and methods from an existing class. For example, a SmartPhone class can inherit from a Phone class.</p>

  <u><strong>Super Class: Subclass</strong></u>
  <p>The subclass extends the superclass.</p>

  <u><strong>Declaring Inheritance in Java</strong></u>
  <p>In Java, Inheritance is declared using the "<b>extends</b>" keyword.</p>

  <u><strong>Superclass: Subclass</strong></u>
  <br>
  <ul>
    <li>The Car class extends the Vehicle class.</li>
    <li>The Dog class extends the Animal class.</li>
    <li>The Cat class extends the Animal class.</li>
    <li>The Truck class extends the Vehicle class.</li>
  </ul>

  <p>When a class inherits from a superclass, it inherits certain methods and fields from the superclass. Java does not support multiple inheritance, which means a subclass cannot have two superclasses.</p>

  <u><strong>Code Example</strong></u>
  <p>Inheritance in Java is declared using the "extends" keyword. For instance, to inherit the Dog class from the Animal class, the code would be:</p>

  <pre><code class="language-java">
public class Dog extends Animal {
  // Code for the Dog class
}
  </code></pre>
  
  <p>
    <b>Is multiple inheritance allowed in Java?</b>
    <br>Multiple inheritance faces problems when there exist methods with the same signature in both the superclasses. Due to such problems, Java does not support multiple inheritance directly. However, a similar concept can be achieved using Interfaces. A class can implement multiple interfaces and extend a class at the same time.
  </p>
<br>
    <h2>Constructors in Inheritance</h2>
    <p>
  <strong>Inheritance</strong> is a concept in Java where a class can inherit properties and methods from another class. The class that is being inherited from is called the <strong>superclass</strong> or parent class, and the class that inherits from it is called the <strong>subclass</strong> or child class.
</p>

<p>
  Now, let's talk about constructors in inheritance. <strong>Constructors</strong> are special methods used to create and initialize objects of a class. When you create an object of a class, its constructor is automatically called to set up the initial state of the object.
</p>

<p>
  When it comes to inheritance, constructors play an important role. Here's what happens:
</p>

<ol>
  <li>
    If the subclass defines its own constructor:
    <ul>
      <li>
        The subclass constructor can have its own parameters and code specific to the subclass.
      </li>
      <li>
        However, the subclass constructor should also call the constructor of the superclass using the <code>super()</code> keyword. This ensures that the inherited members from the superclass are properly initialized.
      </li>
    </ul>
  </li>
  <li>
    If the subclass does not define its own constructor:
    <ul>
      <li>
        The compiler automatically adds a default constructor to the subclass.
      </li>
      <li>
        The default constructor of the subclass implicitly calls the default constructor of the superclass using <code>super()</code>.
      </li>
      <li>
        If the superclass doesn't have a default constructor, you need to explicitly define constructors in both the superclass and subclass to ensure proper initialization.
      </li>
    </ul>
  </li>
</ol>

<p>
  In summary, when a subclass is created, its constructor is responsible for initializing its own members, and it should also invoke the constructor of the superclass to initialize the inherited members.
</p>
<p>Let's walk through an example to illustrate constructors in inheritance:</p>

<pre><code class="language-java">// Superclass
class Vehicle {
    String brand;

    public Vehicle(String brand) {
        this.brand = brand;
    }

    public void displayBrand() {
        System.out.println("Brand: " + brand);
    }
}

// Subclass
class Car extends Vehicle {
    int numberOfDoors;

    public Car(String brand, int numberOfDoors) {
        super(brand); // Calling the constructor of the superclass (Vehicle)
        this.numberOfDoors = numberOfDoors;
    }

    public void displayCarDetails() {
        displayBrand(); // Inherited method from the superclass
        System.out.println("Number of doors: " + numberOfDoors);
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        Car myCar = new Car("Toyota", 4);
        myCar.displayCarDetails();
    }
}
</code></pre>

<p>In the example above, we have a superclass <strong>Vehicle</strong> and a subclass <strong>Car</strong> that inherits from <strong>Vehicle</strong>.</p>

<ol>
  <li>The <strong>Vehicle</strong> class has a constructor that takes a <strong>brand</strong> parameter and initializes the <strong>brand</strong> property of the object.</li>
  <li>The <strong>Car</strong> class has a constructor that takes both <strong>brand</strong> and <strong>numberOfDoors</strong> parameters. It calls the constructor of the superclass (<strong>Vehicle</strong>) using <code>super(brand)</code> to initialize the inherited <strong>brand</strong> property. It then initializes the <strong>numberOfDoors</strong> property of the <strong>Car</strong> object.</li>
  <li>The <strong>Car</strong> class also has a method called <strong>displayCarDetails()</strong> that displays the <strong>brand</strong> (inherited from <strong>Vehicle</strong>) and the <strong>numberOfDoors</strong> specific to the <strong>Car</strong> object.</li>
  <li>In the <strong>main</strong> method, we create an instance of the <strong>Car</strong> class called <strong>myCar</strong> with the brand "Toyota" and 4 doors.</li>
  <li>We call the <strong>displayCarDetails()</strong> method on the <strong>myCar</strong> object, which internally calls the inherited <strong>displayBrand()</strong> method from the superclass and displays the <strong>brand</strong> and <strong>numberOfDoors</strong>.</li>
</ol>

<p>Output:</p>

<pre><code>Brand: Toyota
Number of doors: 4
</code></pre>

<p>In this example, the constructors play a crucial role in properly initializing the object hierarchy. The constructor of the <strong>Car</strong> class invokes the constructor of the superclass (<strong>Vehicle</strong>) using <code>super(brand)</code>, ensuring that the <strong>brand</strong> property is initialized correctly in both the superclass and subclass. This allows us to display the brand and car details accurately.</p>

<p>
  By using constructors in inheritance, you ensure that objects in the subclass hierarchy are properly initialized, including both the subclass-specific and inherited members. Constructors provide a consistent and organized way to initialize objects in an inheritance hierarchy.
</p>
<br><table>
  <tr>
    <td><h2>Excercise: 11</h2>
    
      <ol>
        <li>Create a class named <code>Circle</code> and use inheritance to create another class named <code>Cylinder</code> that extends <code>Circle</code>.</li>
        <li>Create a class named <code>Rectangle</code> and use inheritance to create another class named <code>Cuboid</code> that extends <code>Rectangle</code>. Try to model it as closely as possible to a real-world scenario.</li>
        <li>In the <code>Cuboid</code> class from question 2, create methods for calculating the area and volume. Also, implement appropriate getters and setters for the class.</li>
        <li>Consider the following inheritance hierarchy: <code>Base</code> -> <code>Derived1</code> -> <code>Derived2</code>. What is the order of constructor execution in this hierarchy?</li>
        <li>In the above inheritance hierarchy, if we create an object of <code>Derived2</code> using the statement <code>Derived2 obj = new Derived2();</code>, which constructor (5) will be executed and in what order?</li>
      </ol>
    
      </td>
  </tr>
</table>
    </page>
    <br><br>
    <page>
      <h2>Lesson 19: Abstract Classes and Interfaces</h2>
      <p>Let's dive into a step-by-step explanation of abstract classes and interfaces in Java:</p>

    <strong>Abstract Classes:</strong>

    <p>An abstract class is a class that cannot be instantiated directly but can be used as a base for creating derived classes. It serves as a blueprint for other classes to inherit from. To declare an abstract class, use the <code>abstract</code> keyword before the class declaration. Abstract classes can have both abstract and non-abstract methods. Abstract methods are declared without a body and are meant to be implemented by the derived classes. Abstract classes can also have regular methods with implementations. An abstract class can have instance variables, constructors, and other members like a regular class.</p>
    
    <p>Here is an example of it's structure among main method:</p>
    <pre>
      <code class="language-java">
// Abstract class
abstract class AbstractClass {
    // Abstract method
    public abstract void abstractMethod();

    // Non-abstract method
    public void nonAbstractMethod() {
        // Method implementation
    }
}

// Derived class
class DerivedClass extends AbstractClass {
    // Implement abstract method
    public void abstractMethod() {
        // Method implementation
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        // Create an instance of the derived class
        DerivedClass derivedObject = new DerivedClass();

        // Call methods
        derivedObject.abstractMethod();
        derivedObject.nonAbstractMethod();
    }
}

      </code>
    </pre>
    <strong>Interfaces:</strong>

    <p>An interface is a collection of abstract methods that define a contract for implementing classes. It specifies a set of methods that a class implementing the interface must provide. In Java, an interface is declared using the <code>interface</code> keyword. Interfaces can only contain method declarations and constant values (variables declared with the <code>final</code> keyword).Methods in an interface are implicitly abstract and do not have a body. Classes can implement multiple interfaces, allowing them to inherit behavior from multiple sources. Implementing an interface requires providing implementations for all its declared methods.</p>
    <p>Here is an example of it's structure among main method:</p>
    <pre><code class="language-java">
// Interface
interface MyInterface {
    void myMethod();
}

// Class implementing the interface
class MyClass implements MyInterface {
    public void myMethod() {
        // Implementation of the method
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        // Create an instance of the class implementing the interface
        MyClass myObject = new MyClass();

        // Call the method through the interface reference
        myObject.myMethod();
    }
}

    </code></pre>
<ol>
  <li>
    <p>Differences between Abstract Classes and Interfaces:</p>

    <ul>
      <li>An abstract class can have instance variables and non-abstract methods, while an interface cannot have instance variables and only has method declarations.</li>
      <li>A class can extend only one abstract class but can implement multiple interfaces.</li>
      <li>Abstract classes can provide default implementations for some methods, while interfaces cannot contain method implementations.</li>
      <li>Abstract classes are used when there is a need for common functionality and shared state among derived classes.</li>
      <li>Interfaces are used to define contracts or behavior that classes must adhere to.</li>
      <li>Abstract classes are meant to be extended by derived classes, while interfaces are meant to be implemented by classes.</li>
    </ul>
  </li>

  <li>
    <p>Usage:</p>

    <ul>
      <li>Abstract classes are useful when you want to provide a common base implementation for derived classes and share code among them.</li>
      <li>Interfaces are useful when you want to define a contract that multiple unrelated classes can adhere to, allowing polymorphism and loose coupling.</li>
      <li>Abstract classes are commonly used for creating hierarchies and implementing inheritance.</li>
      <li>Interfaces are commonly used for defining behaviors and enabling classes to support multiple contracts.</li>
    </ul>
  </li>
</ol>

<p>In Java programming (Abstract Classes and Interfaces) plays a crucial role in code organization, design, and achieving abstraction and polymorphism.</p>

      <p>Let's see an another example code to illustrate abstract classes and interfaces in Java:</p>

<ol>
  <li>
    <p>Abstract Class Example:</p>

    <pre><code class="language-java">// Abstract class
abstract class Animal {
    // Abstract method
    public abstract void makeSound();

    // Non-abstract method
    public void sleep() {
        System.out.println("Zzzz...");
    }
}

// Derived class
class Dog extends Animal {
    public void makeSound() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound();
        dog.sleep();
    }
}</code></pre>

    <p>In this example:</p>

    <ul>
      <li>The <code>Animal</code> class is an abstract class that defines an abstract method <code>makeSound()</code> and a non-abstract method <code>sleep()</code>.</li>
      <li>The <code>Dog</code> class extends the <code>Animal</code> class and provides an implementation for the <code>makeSound()</code> method.</li>
      <li>In the <code>Main</code> class, we create an instance of <code>Dog</code> and call its <code>makeSound()</code> and <code>sleep()</code> methods.</li>
    </ul>

    <p>Output:</p>

    <pre><code>Woof!
Zzzz...</code></pre>
  </li>

  <li>
    <p>Interface Example:</p>

    <pre><code class="language-java">// Interface
interface Vehicle {
    void start();
    void stop();
}

// Class implementing the interface
class Car implements Vehicle {
    public void start() {
        System.out.println("Car started");
    }

    public void stop() {
        System.out.println("Car stopped");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start();
        car.stop();
    }
}</code></pre>

    <p>In this example:</p>

    <ul>
      <li>The <code>Vehicle</code> interface defines two methods: <code>start()</code> and <code>stop()</code>.</li>
      <li>The <code>Car</code> class implements the <code>Vehicle</code> interface and provides the implementations for both methods.</li>
      <li>In the <code>Main</code> class, we create an instance of <code>Car</code> and call its <code>start()</code> and <code>stop()</code> methods.</li>
    </ul>

    <p>Output:</p>

    <pre><code>Car started
Car stopped</code></pre>
  </li>
</ol>

<p>These examples showcase the usage of abstract classes and interfaces. The abstract class allows us to define common behavior and leave the implementation to the derived classes. Interfaces, on the other hand, define a contract that classes must adhere to, enabling polymorphism and loose coupling.</p>


<br>


<p>
Note:
<ul>
  <li>Interfaces in Java are similar to classes but with a significant difference. An interface can only have method signatures, constant fields, and default methods.</li>
  <li>The class implementing an interface needs to only declare the methods (not fields). You can create a reference of interfaces but not the object. Interface methods are public by default.</li>
</ul>
</p>

<p>
Default methods:
<ul>
  <li>An interface can have static and default methods.</li>
  <li>Default methods enable us to add new functionality to existing interfaces. This feature was introduced in Java 8 to ensure backward compatibility while updating an interface.</li>
  <li>Classes implementing the interface need not implement the default methods.</li>
  <li>Interfaces can also include private methods for default methods to use.</li>
</ul>
</p>

<br>
<h2>Inheritance in Interfaces</h2>

<p>As we already know, In Java, interfaces play a crucial role in defining contracts for classes. One key feature of interfaces is that they can extend other interfaces, allowing for the creation of a hierarchical structure. This means that an interface can inherit the methods and constants defined in another interface.</p>

<p>For example, let's consider two interfaces: <code><strong>Interface1</strong></code> and <code><strong>Interface2</strong></code>. If <code><strong>Interface2</strong></code> extends <code><strong>Interface1</strong></code>, it means that <code><strong>Interface2</strong></code> incorporates all the methods and constants defined in <code><strong>Interface1</strong></code>, in addition to any new ones it declares.</p>

<p>Let's see an example:</p>

<pre><code class="language-java">
public interface Interface1 {
    void method1();
}

public interface Interface2 extends Interface1 {
    void method2();
}
</code></pre>

<p>In the code snippet above, <code><strong>Interface2</strong></code> extends <code><strong>Interface1</strong></code>, indicating that any class implementing <code><strong>Interface2</strong></code> must provide implementations for both <code><strong>method1()</strong></code> and <code><strong>method2()</strong></code>.</p>

<p>It's important to note that interfaces themselves cannot implement other interfaces. Implementation is a concept applicable to classes, not interfaces. A class can implement multiple interfaces, thus fulfilling the contracts defined by each interface.</p>

<p>Regarding polymorphism using interfaces, let's take the example of a Smart Phone that incorporates various functionalities like GPS, Camera, and Media Player. Each of these functionalities can be represented by separate interfaces. By implementing these interfaces, the Smart Phone class can exhibit polymorphic behavior, allowing it to be treated as a GPS device, a camera, or a media player interchangeably.</p>

<p>Let's explore an example based on it:</p>

<pre><code class="language-java">
public interface GPS {
    void navigate();
}

public interface Camera {
    void capturePhoto();
}

public interface MediaPlayer {
    void playMedia();
}

public class SmartPhone implements GPS, Camera, MediaPlayer {
    // Implementations of methods defined in GPS, Camera, and MediaPlayer interfaces
}
</code></pre>

<p>In the example code above, the <code><strong>SmartPhone</strong></code> class implements the <code><strong>GPS</strong></code>, <code><strong>Camera</strong></code>, and <code><strong>MediaPlayer</strong></code> interfaces, providing concrete implementations for the methods defined in each of these interfaces. This enables the <code><strong>SmartPhone</strong></code> object to be used as a GPS device, a camera, or a media player, depending on the context.</p>

<p>In a nutshell, Interfaces can extend other interfaces to inherit their methods and constants. Implementing multiple interfaces in a class enables polymorphic behavior, where objects can be treated as different types interchangeably, based on the interfaces they implement.</p>
<br>
<table>
  <tr>
    <td><h2>Excercise: 12</h2>
    <ol>
      <li>How can we utilize the Pen Class mentioned in the previous question to create a new object or perform a specific action?</li>
      <li>
        Can you provide an example of an abstract class called "Pen" with abstract methods <code>write()</code> and <code>refill()</code>? Additionally, can you demonstrate the implementation of a concrete class named "FountainPen" that extends the Pen class and includes an additional method called <code>changeNib()</code>? Furthermore, could you explain the structure of a class called "Monkey" with the functionalities of <code>jump()</code> and <code>bite()</code>? Lastly, can you describe the design of a class named "Human" that inherits from the Monkey class and implements the BasicAnimal interface, including the <code>eat()</code> and <code>sleep()</code> methods?
      </li>
      <li>
        How can we design a class called "Telephone" that consists of abstract methods for <code>ring()</code>, <code>lift()</code>, and <code>disconnect()</code>? Subsequently, can you demonstrate the concept of polymorphism by creating another class named "SmartTelephone" and showcasing how it can exhibit varying behaviors based on the Telephone class?
      </li>
      <li>In what way can we showcase polymorphism using the functionalities provided by the Monkey class mentioned in the previous question?</li>
      <li>
        Can you explain the process of creating an interface called "TVRemote" and inheriting it from another interface called "SmartTVRemote"? Additionally, can you elaborate on the implementation of a class called "TV" that implements the TVRemote interface?
      </li>
    </ol></td>
  </tr>
</table>
    </page>
    <br></br>
    <page>
      <h2>Lesson 15: Packages</h2>
  <p>
    In Java, a package is a way to organize related classes, interfaces, and other resources. It provides a mechanism for creating namespaces, which help avoid naming conflicts and make code more manageable.
  </p>
  <strong>Package Naming Conventions</strong>
  <p>
    Packages in Java follow a naming convention that uses a reversed domain name. For example, if your domain name is "example.com," your package names would typically start with "com.example."
  </p>
  <strong>Creating a Package</strong>
  <p>
    To create a package, you need to follow a specific directory structure. Let's say you want to create a package called "com.example.myapp." You would create a directory called "com" and inside it, create another directory called "example." Finally, inside the "example" directory, create a directory called "myapp." This structure represents the package hierarchy.
  </p>
  <strong>Package Declarations</strong>
  <p>
    To include a class in a specific package, you need to declare the package at the beginning of the Java file using the <code>package</code> keyword. For example, if you want a class to belong to the "com.example.myapp" package, you would add the following line at the top of your Java file:
  </p>
  <pre><code class="language-java">
package com.example.myapp;
  </code></pre>
  <strong>Accessing Classes from Other Packages</strong>
  <p>
    To access a class from another package, you need to use its fully qualified name, which includes the package name. If you have a class called <code>MyClass</code> in the "com.example.myapp" package and want to use it in another class, you would write:
  </p>
  <pre><code class="language-java">
com.example.myapp.MyClass obj = new com.example.myapp.MyClass();
  </code></pre>
  <p>
    Alternatively, you can use the <code>import</code> statement at the beginning of your Java file to avoid using the fully qualified name every time. For example:
  </p>
  <pre><code class="language-java">
import com.example.myapp.MyClass;

// ...

MyClass obj = new MyClass();
  </code></pre>
  <strong>Compiling and Running Packages</strong>
  <p>
    When compiling Java files in packages, you need to ensure that the directory structure matches the package structure. For example, if you have a file called <code>MyClass.java</code> in the "com.example.myapp" package, the directory structure should be:
  </p>
  <pre><code class="language-java">
com
â””â”€â”€ example
    â””â”€â”€ myapp
        â””â”€â”€ MyClass.java
  </code></pre>
  <p>
    To compile the file, navigate to the directory containing the top-level package (in this case, "com") and use the <code>javac</code> command:
  </p>
  <pre><code class="language-java">
javac com/example/myapp/MyClass.java
  </code></pre>
  <p>
    To run the compiled file, use the <code>java</code> command and provide the fully qualified name of the class:
    </p>
    <pre><code class="language-java">
java com.example.myapp.MyClass
      </code></pre>
      <strong>Creating packages</strong>
      <p>For creating our package, we can execute the following command in our terminal/command prompt:</p>
  <pre>
    <code>
javac -d FileName.java
    </code>
  </pre>
      <h2>Explanation of Import Statements</h2>
  <p>
    In Java, the <code>import</code> statement is used to make classes and other types from other packages accessible in the current file without specifying their fully qualified names each time they are used.
  </p>
  <p>
    When you want to use a class or a type from another package, you have two options:
  </p>
  <ol>
    <li>Use the fully qualified name: You can use the fully qualified name of the class or type, which includes the package name. For example:</li>
  </ol>
  <pre><code class="language-java">
com.example.myapp.MyClass obj = new com.example.myapp.MyClass();
  </code></pre>
  <ol start="2">
    <li>Use the <code>import</code> statement: Instead of using the fully qualified name, you can import the class or type at the beginning of your Java file using the <code>import</code> statement. This allows you to refer to the class or type by its simple name (without the package name) throughout the file. For example:</li>
  </ol>
  <pre><code class="language-java">
import com.example.myapp.MyClass;

// ...

MyClass obj = new MyClass();
  </code></pre>
  <h2>Importing Classes</h2>
  <ul>
    <li>The <code>import</code> statement is placed at the top of the Java file, before any class declarations.</li>
    <li>You can have multiple <code>import</code> statements in a file, each importing a different class or type.</li>
    <li>The import statement can import a single class, multiple classes from the same package, or all classes from a package.</li>
    <li>The import statement only affects the file it is written in; it does not affect other files or the visibility of classes in other files.</li>
    <li>If you import two classes with the same name from different packages, you need to use the fully qualified name in your code to disambiguate between them.</li>
  </ul>
  <p>
    Here are a few examples of import statements:
  </p>
  <pre><code class="language-java">
import java.util.ArrayList;  // Importing a single class
import java.util.*;          // Importing all classes from the java.util package
import com.example.myapp.MyClass;  // Importing a class from a specific package
  </code></pre>
  <p>
    Using import statements can make your code more readable and concise by allowing you to refer to classes and types using their simple names. However, it's important to use them judiciously and avoid excessive imports to prevent naming conflicts and maintain code clarity.
  </p>
  
  <table>
    <tr>
      <td>
        <h2>Excercise: 13</h2>
          <ol>
            <li>Create three classes: Calculator, ScientificCalculator, and HybridCalculator, and group them into a package named "com.example.calculators".</li>
        
            <li>Use the built-in package in Java to write a class that takes input from the user and displays a message using <code>System.out.println()</code>.</li>
        
            <li>Create a package hierarchy with three levels: "folder", "folder1", and "folderL2". Each level should contain a package with the corresponding name.</li>
        
            <li>Prove that you cannot access a default (package-private) property from a subclass, but you can access a protected property from a subclass.</li>
          </ol>
      </td>
    </tr>
  </table>

    </page>

    <br><br>
    <page>
      <h2>Lesson 16: Multithreading</h2>
      <p>Multithreading in Java is a concept that <strong>allows multiple tasks or threads to run concurrently within a single program</strong>. Think of it as having multiple workers who can perform different tasks at the same time.</p>
      <p>Some  characteristics of threads are-</p>
      <ol>
        <li><strong>Lightweight:</strong> Threads are lightweight compared to processes. Creating and managing threads requires fewer system resources.</li>
        <li><strong>Concurrency:</strong> Threads allow concurrent execution of multiple tasks within a single program. Each thread can perform a separate set of instructions independently.</li>
        <li><strong>Shared Memory:</strong> Threads within the same process share the same memory space. This allows them to communicate and share data by directly accessing shared variables.</li>
        <li><strong>Context Switching:</strong> The processor can quickly switch between threads, allowing them to appear as if they are running simultaneously. Context switching allows multiple threads to make progress in parallel.</li>
        <li><strong>Synchronization:</strong> Threads can be synchronized to coordinate their actions and access shared resources safely. Synchronization mechanisms like locks, semaphores, and monitors are used to ensure thread safety and prevent data corruption.</li>
        <li><strong>Interference:</strong> Concurrent threads can interfere with each other if they access and modify shared data simultaneously. Care must be taken to properly synchronize access to shared resources to avoid unexpected results.</li>
        <li><strong>Priority:</strong> Threads can have different priorities assigned to them. Higher priority threads are given more preference by the scheduler for execution. However, thread priority is only a hint and not a strict guarantee of execution order.</li>
        <li><strong>Lifecycle:</strong> Threads have a lifecycle consisting of different states, such as New, Runnable, Blocked, Waiting, Timed Waiting, and Terminated. They can transition between these states based on their execution and synchronization requirements.</li>
        <li><strong>Communication:</strong> Threads can communicate with each other through various mechanisms such as shared variables, locks, wait/notify, and message passing, enabling coordination and synchronization between them.</li>
        <li><strong>Scalability:</strong> By utilizing multiple threads, applications can potentially achieve improved performance and scalability on multi-core and multi-processor systems.</li>
      </ol>
      <br>
      <h2>Control Flow</h2>
  
<strong>If we don't use multithreading...</strong>
<p>In a Java program that operates on a single thread, the control flow is straightforward. The program initiates execution from the main method and proceeds to execute statements in a sequential manner, one after another. It progresses through the program from the top to the bottom, executing each statement until it reaches the program's end or encounters conditional statements such as if, switch, or loop.

The control flow in this scenario is predictable and adheres to a deterministic pattern. Each statement is executed sequentially, and the program waits for the completion of each statement before moving on to the next one. If there are time-consuming tasks or operations that block the program, it may encounter delays in execution until those tasks are finished.
</p>
<strong>But if we use multithreading...</strong>
<p>When threading is incorporated into a Java program, the control flow becomes more complex and dynamic. Multiple threads are created, and each thread possesses its own execution path that can run concurrently with other threads.

In a program employing multithreading, the control flow is not necessarily sequential. Threads can execute different segments of the program simultaneously. The order and timing of thread execution are managed by the operating system's scheduler and the Java runtime environment.
</p>
<p>
Threads can execute concurrently, independently performing their own set of instructions. They can communicate and share data through shared variables or synchronization mechanisms. The control flow can transition between threads based on the scheduler's decisions or explicit synchronization constructs.

<strong>In a multithreaded program,</strong>  the execution order and interleaving of statements between threads can be non-deterministic. This lack of determinism can give rise to challenges related to thread synchronization, race conditions, and thread safety. To ensure the correct and predictable behavior of the program, suitable synchronization mechanisms and coordination techniques need to be employed.

<strong>In a nutshell, </strong>A Java program without threading, the control flow follows a <strong>sequential and predictable path.</strong> However, with the introduction of threading, multiple threads can execute concurrently, resulting in a more dynamic and less predictable control flow. Consequently, careful management and synchronization are necessary to avoid potential issues.
<h2>Lifecycle of a Thread</h2>

    <center>    <img src="t.png" height="50%" width="50%"></center>
<br>
<ol>
  <li><strong>New</strong>: Creates Instance of thread, which is not yet started by invoking <code>start()</code> </li>
  <li><strong>Runnable</strong>: After invocation of <code>start()</code> and before it's selected to be run by <b>the scheduler</b>. </li>
  <li><strong>Running</strong>: After thread scheduler has selected it.</li>
  <li><strong>Non Runnable (Blocked)</strong>: Thread is alive but not eligible to run.</li>
  <li><strong>Terminated</strong>: <code>run()</code> method has stopped.</li>
</ol>
<br>
<h2>Thread Class Constructors</h2>
<p>The Thread class in Java provides several constructors for creating and initializing threads. Here are some commonly used constructors of the Thread class:</p>

<ol>
  <li>
    <strong>Thread()</strong>
    <ul>
      <li>Creates a new thread object.</li>
      <li>The new thread will have a default name assigned by the system.</li>
    </ul>
  </li>
  <li>
    <strong>Thread(Runnable target)</strong>
    <ul>
      <li>Creates a new thread object with the specified Runnable target.</li>
      <li>The Runnable target represents the object whose run method will be executed by the thread.</li>
      <li>This constructor allows you to associate a runnable object with the thread.</li>
    </ul>
  </li>
  <li>
    <strong>Thread(Runnable target, String name)</strong>
    <ul>
      <li>Creates a new thread object with the specified Runnable target and name.</li>
      <li>The Runnable target represents the object whose run method will be executed by the thread.</li>
      <li>The name parameter allows you to assign a custom name to the thread.</li>
    </ul>
  </li>
  <li>
    <strong>Thread(String name)</strong>
    <ul>
      <li>Creates a new thread object with the specified name.</li>
      <li>The name parameter allows you to assign a custom name to the thread.</li>
    </ul>
  </li>
  <li>
    <strong>Thread(ThreadGroup group, Runnable target)</strong>
    <ul>
      <li>Creates a new thread object with the specified ThreadGroup and Runnable target.</li>
      <li>The ThreadGroup represents the thread group to which the thread will belong.</li>
      <li>The Runnable target represents the object whose run method will be executed by the thread.</li>
    </ul>
  </li>
  <li>
    <strong>Thread(ThreadGroup group, Runnable target, String name)</strong>
    <ul>
      <li>Creates a new thread object with the specified ThreadGroup, Runnable target, and name.</li>
      <li>The ThreadGroup represents the thread group to which the thread will belong.</li>
      <li>The Runnable target represents the object whose run method will be executed by the thread.</li>
      <li>The name parameter allows you to assign a custom name to the thread.</li>
    </ul>
  </li>
</ol>

<p>These are some of the commonly used constructors of the Thread class in Java. Each constructor allows you to create and initialize threads with different parameters and configurations based on your specific requirements.</p>
<br>
<strong>Some commonly used methods of the <code>Thread</code> class are:</strong>
<ol>
  <li>
    <code>start()</code>: This method starts the execution of a thread by calling its <code>run()</code> method. It allows the thread to be scheduled and run concurrently with other threads.
  </li>
  <li>
    <code>run()</code>: This method contains the code that is executed when the thread starts. It needs to be overridden in a subclass to define the specific behavior of the thread.
  </li>
  <li>
    <code>sleep(long millis)</code>: This method pauses the execution of the current thread for the specified number of milliseconds. It is often used for introducing delays or for timing-related operations.
  </li>
  <li>
    <code>join()</code>: This method allows one thread to wait for the completion of another thread. When a thread calls <code>join()</code> on another thread, it waits until that thread finishes its execution before continuing.
  </li>
  <li>
    <code>isAlive()</code>: This method returns a boolean value indicating whether a thread is currently alive or not. A thread is considered alive from the moment it is started until it completes its execution.
  </li>
  <li>
    <code>interrupt()</code>: This method interrupts the execution of a thread by setting its interrupt status. It can be used to politely request the thread to stop its execution.
  </li>
  <li>
    <code>isInterrupted()</code>: This method checks whether the interrupt status of a thread has been set. It returns a boolean value indicating whether the thread has been interrupted.
  </li>
  <li>
    <code>yield()</code>: This method suggests to the scheduler that the current thread is willing to yield its current use of the CPU. It allows other threads with the same priority to have a chance to run.
  </li>
  <li>
    <code>setName(String name)</code>: This method sets the name of the thread. The thread's name can be useful for identification and debugging purposes.
  </li>
  <li>
    <code>getName()</code>: This method returns the name of the thread.
  </li>
</ol>
<p>These are just a few of the commonly used methods of the <code>Thread</code> class in Java. The class provides several other methods and static utility methods for thread management, synchronization, and coordination.</p>
<br>
<h2>Creating a thread</h2>
<p>Basically, <strong>there are two ways to create a thread in Java</strong></p>
<ol>
  <li>
    <strong>Extending the Thread class:</strong>
  
    <p>
      One way to create a thread in Java is by extending the <code>Thread</code> class. Here are the steps involved:
    </p>
    <ol>
      <li>Create a new class that extends the <code>Thread</code> class.</li>
      <li>Override the <code>run()</code> method in the new class. This method contains the code that will be executed when the thread starts.</li>
      <li>Instantiate an object of the new class.</li>
      <li>Call the <code>start()</code> method on the object to start the thread.</li>
    </ol>
    <pre><code>
class MyThread extends Thread {
    public void run() {
        // Code to be executed by the thread
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        // Create an instance of the MyThread class
        MyThread myThread = new MyThread();
        
        // Start the thread
        myThread.start();
    }
}
    </code></pre>
  </li>
  <li>
    <strong>Implementing the Runnable interface:</strong>
    <p>
      Another way to create a thread in Java is by implementing the <code>Runnable</code> interface. Here are the steps involved:
    </p>
    <ol>
      <li>Create a new class that implements the <code>Runnable</code> interface.</li>
      <li>Implement the <code>run()</code> method defined in the <code>Runnable</code> interface. This method contains the code that will be executed when the thread starts.</li>
      <li>Instantiate an object of the new class.</li>
      <li>Create a <code>Thread</code> object, passing the new class instance as a parameter to its constructor.</li>
      <li>Call the <code>start()</code> method on the <code>Thread</code> object to start the thread.</li>
    </ol>
    <pre><code>
class MyRunnable implements Runnable {
    public void run() {
        // Code to be executed by the thread
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        // Create an instance of the MyRunnable class
        MyRunnable myRunnable = new MyRunnable();
        
        // Create a Thread object, passing the MyRunnable instance
        Thread myThread = new Thread(myRunnable);
        
        // Start the thread
        myThread.start();
    }
}
    </code></pre>
  </li>
</ol>

Both approaches allow you to create and start a new thread in Java. Extending the `Thread` class provides a bit more flexibility, while implementing the `Runnable` interface allows you to separate the thread's behavior from the class hierarchy.
    <br><br>
    <table>
      <tr>
        <td>
          <h2>Excercise: 14</h2>
          <ol>
            <li>Write a program to print "Good Evening" and  "Welcome" continiously on the screen using Threads</li>
            <li>Add a sleep method in Welcome thread of question 1 to delay it's execution for 1000ms. </li>
            <li>Demonstrate <code>getPrirority()</code> and <code>setPrirority()</code> methods in Java threads.</li>
            <li>How can you get state of a given thread in Java?</li>
            <li>How can you get reference to the current thread in Java?</li>
          </ol>
        </td>
      </tr>
    </table>
</page>
<br><br>
<page>
  <h2>Lesson 17: Errors and Exceptions</h2>
  <p>No matter how intelligent we may be, <b>errors persist as our steadfast companions.</b> Through ample practice, we continually enhance our ability to identify and rectify them.</p>
<p>There are <strong>three</strong> types of errors in Java.</p> They are:
<ol>
  <li>Syntax Errors</li>
  <li>Logical Errors</li>
  <li>Exceptions (Runtime Errors)</li>
</ol>
<br>
<strong>Syntax Errors</strong>
When the compiler detects an issue in our program, it throws a <strong>syntax error</strong>.
<pre>
  <code class="language-java">
int a=7 //No semicolon, syntax error.
a=a+3;
r=4; // Variable not declared, syntax error.
  </code>
</pre>
<br>
<strong>Logical Errors</strong>
<p>A logical error or bug arises when a program compiles and executes but <b>performs an incorrect action</b>. Examples of such errors include delivering messages inaccurately, displaying chat times incorrectly, allowing login success with an incorrect username or password, and so on.
</p>
<br>
<strong>Exceptions (Runtime Errors)</strong>
<p>While running a Java program, it is possible to encounter errors known as exceptions. These exceptions arise from various circumstances, such as bad input or resource constraints. </p>
</p>
<p><strong>Programmers often come across syntax errors and logical errors, while it is the user who typically encounters runtime errors.</strong></p>
<br>
<strong>Exceptions in Java</strong>
<p>Exception Handling is crucial in Java programming as it deals with events that disrupt the regular flow of instructions during program execution. In Java, we primarily encounter <strong>two types of exceptions</strong>. They are:</p>
<ol>
  <li>Checked Exceptions: These exceptions are detected at compile time and they are handled by the Java compiler.</li>
  <li>Unchecked Exceptions: Runtime exceptions that do not require explicit handling.</li>
</ol>
<br>

<strong>To handle any type of exception, you need to import its respective exception class. The following are the most commonly encountered exceptions along with their import codes:</strong>
<table>
  <tr>
    <th>Exception</th>
    <th>Import Class</th>
  </tr>
  <tr>
    <td>NullPointerException</td>
    <td><code>java.lang.NullPointerException</code></td>
  </tr>
  <tr>
    <td>ArrayIndexOutOfBoundsException</td>
    <td><code>java.lang.ArrayIndexOutOfBoundsException</code></td>
  </tr>
  <tr>
    <td>IllegalArgumentException</td>
    <td><code>java.lang.IllegalArgumentException</code></td>
  </tr>
  <tr>
    <td>IllegalStateException</td>
    <td><code>java.lang.IllegalStateException</code></td>
  </tr>
  <tr>
    <td>ClassCastException</td>
    <td><code>java.lang.ClassCastException</code></td>
  </tr>
  <tr>
    <td>FileNotFoundException</td>
    <td><code>java.io.FileNotFoundException</code></td>
  </tr>
  <tr>
    <td>IOException</td>
    <td><code>java.io.IOException</code></td>
  </tr>
  <tr>
    <td>ArithmeticException</td>
    <td><code>java.lang.ArithmeticException</code></td>
  </tr>
  <tr>
    <td>NoSuchMethodException</td>
    <td><code>java.lang.NoSuchMethodException</code></td>
  </tr>
  <tr>
    <td>UnsupportedOperationException</td>
    <td><code>java.lang.UnsupportedOperationException</code></td>
  </tr>
</table>
<br>
Here's a basic structure with <code>try</code> and <code>catch</code> block
<br>
<pre>
  <code class="language-java">
import exceptionclass;
public class classname{
  public static void main(String[] args){
    try{
      //code that may throw an exception
    } catch (ExceptionName e){
      //handling the exception
    }
  }
}
  </code>
</pre>
<br>
<h2>Exception Class Methods</h2>
  <p>The <code>Exception</code> class in Java is the base class for all exceptions. It provides several important methods for working with exceptions. Here are some of the commonly used methods of the <code>Exception</code> class:</p>
  
  <ol>
    <li>
      <code>getMessage()</code>: This method returns a detailed message about the exception. It provides information about the specific cause of the exception and is typically used for debugging or logging purposes.
    </li>
    <li>
      <code>printStackTrace()</code>: This method prints the stack trace of the exception, including the sequence of method calls that led to the exception. It helps in identifying the exact location and sequence of method invocations when the exception occurred. This method is often used during debugging to analyze the flow of the program.
    </li>
    <li>
      <code>toString()</code>: This method returns a string representation of the exception object. It usually includes the class name and a brief description of the exception. The <code>toString()</code> method is automatically called when an exception object is printed using <code>System.out.println()</code> or concatenated with a string.
    </li>
    <li>
      <code>getCause()</code>: This method returns the cause of the exception, which is typically another exception that triggered the current exception. It is useful for chained exceptions, where one exception is caused by another.
    </li>
    <li>
      <code>getStackTrace()</code>: This method returns an array of <code>StackTraceElement</code> objects representing the stack trace of the exception. Each <code>StackTraceElement</code> contains information about a single method call in the stack trace, including the class name, method name, and line number.
    </li>
    <li>
      <code>printStackTrace(PrintStream stream)</code> / <code>printStackTrace(PrintWriter writer)</code>: These overloaded methods print the stack trace of the exception to the specified <code>PrintStream</code> or <code>PrintWriter</code> instead of the standard error stream. This allows you to redirect the stack trace output to a file or any other desired destination.
    </li>
  </ol>
  <br>
<h2>Throws keyword</h2>
  
  <p>The <code>throws</code> keyword in Java is used in method declarations to indicate the possibility of the method throwing one or more exceptions. It plays a crucial role in the Java exception handling mechanism. Here's an explanation of the <code>throws</code> keyword:</p>

  <p>In Java, when a method may encounter an exception but does not handle it internally, it can declare the exception using the <code>throws</code> keyword. By declaring an exception with <code>throws</code>, the method acknowledges that it may not directly handle the exception and instead expects the calling code to handle or propagate it.</p>

  <p>The syntax for using the <code>throws</code> keyword is as follows:</p>

  <pre><code class="language-java">return_type methodName(parameters) throws ExceptionType1, ExceptionType2, ... {
    // Method code that may throw exceptions
  }</code></pre>

  <p>To illustrate the usage of the <code>throws</code> keyword, consider the following example:</p>

  <pre><code class="language-java">public class Example {
public static void main(String[] args) {
  try {
      divide(10, 0);
      } catch (ArithmeticException e) {
         System.out.println("An exception occurred: " + e.getMessage());
        }
  }

public static void divide(int numerator, int denominator) throws ArithmeticException {
  if (denominator == 0) {
    throw new ArithmeticException("Cannot divide by zero");
      }
    int result = numerator / denominator;
    System.out.println("Result: " + result);
  }
}</code></pre>

  <p>In the given example, the <code>divide</code> method accepts two integer parameters, numerator and denominator. It employs the <code>throws</code> keyword to declare that it may throw an <code>ArithmeticException</code> if the denominator is zero.</p>

  <p>In the <code>main</code> method, when calling the <code>divide</code> method, we wrap it within a <code>try-catch</code> block to handle any potential exception. If the <code>divide</code> method encounters an exception (in this case, when the denominator is zero), it throws an <code>ArithmeticException</code>, which is then caught and handled by the corresponding <code>catch</code> block.</p>

  <p>By declaring the exception with <code>throws</code> in the method signature, we inform the caller that this method may throw an exception and should handle it appropriately. It grants the caller the freedom to decide how to handle the exception, whether by catching it or propagating it to its own caller.</p>

  <p>The usage of the <code>throws</code> keyword aids in separating the responsibility of exception handling among different sections of the code and promotes effective error management and modularity.</p>
<br>
<h2>Finally Block</h2>
  <p>In Java, the "finally" block is used in exception handling along with the "try" and "catch" blocks. The "finally" block contains code that is <strong>always executed</strong>, regardless of whether an <strong>exception occurs or not</strong>.</p>
  
<strong>How the "finally" block works?</strong>
  <ol>
    <li>A "try" block is used to enclose the code that may potentially throw an exception.</li>
    <li>If an exception occurs within the "try" block, the execution of the block is immediately stopped, and the control is transferred to the corresponding "catch" block.</li>
    <li>The "catch" block catches the exception and handles it accordingly. It may perform error handling, logging, or any other necessary operations.</li>
    <li>After the "catch" block is executed, the "finally" block is executed, regardless of whether an exception occurred or not. The code inside the "finally" block is always executed, even if an exception was caught or if the "try" block completed successfully.</li>
  </ol>
  
<br>
<strong>Key points about the "finally" block</strong>
  <ul>
    <li>The "finally" block is optional. You can have a "try" block without a "catch" block, but if you have a "finally" block, it must be associated with a "try" block.</li>
    <li>The "finally" block is typically used to clean up resources, release locks, close files, or perform any necessary cleanup operations, regardless of whether an exception occurred.</li>
    <li>If there is a "return" statement inside the "try" or "catch" block, the "finally" block will be executed before the method returns. This ensures that any necessary cleanup or final operations are performed before exiting the method.</li>
    <li>If an exception occurs within the "finally" block itself, it will override any previous exception that was caught or thrown in the "try" or "catch" blocks. The new exception will be propagated to the caller.</li>
  </ul>

  <br>
  Here's an template:
  <pre>
    <code class="language-java">
try {
  / Code that may throw an exception
  // ...
  } catch (ExceptionType exception) {
  // Exception handling for ExceptionType1
  // ...
  } finally {
  // Code that is always executed
  // ...
  }
    </code>
  </pre>

  <br><br>
  <table>
    <tr>
      <td>
        <h2>Excercise: 15</h2>
<ol>
  <li>Write a Java program to demonstrate syntax and logical errors!</li>
  <li>Write a Java program that prints "looooll" during an ArithmeticException and "I am drunk" during an IllegalArgumentException, allowing you to keep accessing it.</li>
  <li>Write a program in Java that allows you to keep accessing it until a valid index is given. If the maximum number of retries exceeds 5, print "Error".</li>
  <li>Modify the program in Question 3 to throw a custom exception when the maximum number of retries is reached.</li>
  <li>Wrap the program in Question 3 inside a method which throws your custom exception.</li>
</ol>
      </td>
    </tr>
  </table>
<p></p>
</page>
<br><br>
<page>
  <h2>Lesson 18: List</h2>
  <p>In Java, a list is a useful tool for storing and handling collections of elements. It's part of the Java Collections Framework and offers various methods for adding, removing, and accessing elements within the list.</p>
  
  <strong>Importing the List class</strong>
  <p>To utilize a list in Java, you need to import the <code>java.util.List</code> class. This can be done by including the following line at the start of your Java file:</p>
  <pre><code class="language-java">import java.util.List;</code></pre>
  
  <strong>Creating a list</strong>
  <p>Once you've imported the <code>List</code> class, you can create a list object and perform operations on it. For instance, you can create a list like this:</p>
  <pre><code class="language-java">List&lt;String&gt; myList = new ArrayList&lt;&gt;();</code></pre>
  <p>In this example, <code>myList</code> is a list capable of storing elements of type <code>String</code>. The <code>ArrayList</code> class serves as an implementation of the <code>List</code> interface.</p>
  
  <strong>Commonly used methods for lists in Java</strong>
  <ol>
    <li><code>add(element)</code>: Appends the specified element to the end of the list. For example: <pre><code class="language-java">myList.add("apple");</code></pre></li>
    <li><code>get(index)</code>: Retrieves the element at the specified index in the list. For example: <pre><code class="language-java">String firstElement = myList.get(0);</code></pre></li>
    <li><code>remove(index)</code>: Deletes the element at the specified index from the list. For example: <pre><code class="language-java">myList.remove(0);</code></pre></li>
    <li><code>size()</code>: Returns the number of elements in the list. For example: <pre><code class="language-java">int size = myList.size();</code></pre></li>
    <li><code>contains(element)</code>: Checks if the list contains the specified element and returns a boolean value. For example: <pre><code class="language-java">boolean containsApple = myList.contains("apple");</code></pre></li>
    <li><code>isEmpty()</code>: Checks if the list is empty and returns a boolean value. For example: <pre><code class="language-java">boolean empty = myList.isEmpty();</code></pre></li>
  </ol>
  <br><br>
  <table>
    <tr>
      <td>
        <h2>Excercise: 16</h2>
        <ol>
          <li>
            <p>Create an empty list of integers called <code>numberList</code>.</p>
          </li>
          <li>
            <p>Add the numbers 1, 2, and 3 to the <code>numberList</code> using appropriate methods.</p>
          </li>
          <li>
            <p>Retrieve and store the second element of <code>numberList</code> in a variable called <code>secondNumber</code>.</p>
          </li>
          <li>
            <p>Remove the first element from <code>numberList</code>.</p>
          </li>
          <li>
            <p>Check if <code>numberList</code> contains the number 5 and store the result in a variable called <code>containsFive</code>.</p>
          </li>
        </ol>
      </td>
    </tr>
  </table>
</page>
<br><br>
<page>
  <h2>Lesson 20: ArrayList, LinkedList, HashMap and Stack</h2>
  <p><strong>Arraylist</strong>The ArrayList class is a type of array that can be resized dynamically and is located in the java.util package.
<br>
    In Java, the key distinction between a built-in array and an ArrayList is that <strong>the size of an array cannot be changed</strong>. If you need to add or remove elements in an array, <strong>you must create a new array</strong>. On the other hand, an <strong>ArrayList allows for the addition and removal of elements at any time</strong>. The syntax for working with an ArrayList also differs slightly.</p>
<strong>Importing the ArrayList class</strong>
<pre>
  <code class="language-java">
    import java.util.ArrayList;
  </code>
</pre>

<li>
  <strong>Creating an ArrayList</strong>
  <p>Declare a variable of type ArrayList, specifying the type of elements it will hold within the angle brackets (<code>&lt;&gt;</code>). For example, to create an ArrayList of integers, you can use the following code:</p>
  <pre><code class="language-java">ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;&gt;();</code></pre>
  <p>Here, <code>numberList</code> is the name of the ArrayList, and it will store elements of type Integer.</p>
</li>
<li>
  <p>You can add elements to the ArrayList using the <code>add()</code> method. For example, to add an integer value to the list, you can use the following code:</p>
  <pre><code class="language-java">numberList.add(10);
numberList.add(20);
numberList.add(30);</code></pre>
  <p>In this example, we added three integers (10, 20, and 30) to the <code>numberList</code> ArrayList.</p>
</li>
</ol>
<strong>Commonly used methods for Arraylist in Java</strong>
<ol>
  <li>
    <strong>add(element)</strong>
    <p>Adds the specified element to the end of the ArrayList.</p>
    <pre><code class="language-java">ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();
numbers.add(10);
</code></pre>
  </li>
  <li>
    <strong>get(index)</strong>
    <p>Retrieves the element at the specified index from the ArrayList.</p>
    <pre><code class="language-java">int firstElement = numbers.get(0);
</code></pre>
  </li>
  <li>
    <strong>set(index, element)</strong>
    <p>Updates the element at the specified index with the given element.</p>
    <pre><code class="language-java">numbers.set(0, 20);
</code></pre>
  </li>
  <li>
    <strong>remove(index)</strong>
    <p>Deletes the element at the specified index from the ArrayList.</p>
    <pre><code class="language-java">numbers.remove(0);
</code></pre>
  </li>
  <li>
    <strong>size()</strong>
    <p>Returns the number of elements in the ArrayList.</p>
    <pre><code class="language-java">int size = numbers.size();
</code></pre>
  </li>
  <li>
    <strong>contains(element)</strong>
    <p>Checks if the ArrayList contains the specified element and returns a boolean value.</p>
    <pre><code class="language-java">boolean containsTen = numbers.contains(10);
</code></pre>
  </li>
  <li>
    <strong>isEmpty()</strong>
    <p>Checks if the ArrayList is empty and returns a boolean value.</p>
    <pre><code class="language-java">boolean empty = numbers.isEmpty();
</code></pre>
  </li>
</ol>
<br><p>
<strong>LinkedList: </strong>
In the Java programming language, a LinkedList is a data structure used to represent a collection of elements. It belongs to the Java Collections Framework and is provided as a class within the java.util package.

<strong>LinkedLists are a specific type of list that organizes elements in a sequential manner</strong>. Unlike ArrayLists, which use an array to store elements, LinkedLists utilize a doubly linked list structure. <strong>Each element in a LinkedList is associated with a node that holds references to both the previous and next nodes in the sequence</strong>.

LinkedLists offer various operations to manipulate the elements stored within them. These operations include adding elements at the beginning or end of the list, inserting elements at specific positions, removing elements, and retrieving elements based on their index.
 <br>
One advantage of using LinkedLists is their efficiency in insertion and deletion operations, particularly when dealing with large or frequently changing lists. LinkedLists may exhibit slower access times compared to ArrayLists when accessing elements by their index. This is because accessing an element by index in a LinkedList requires traversing the list from either the beginning or end.
</p>
<br>
<strong>Importing the LinkedList class</strong>
<pre>
  <code class="language-java">
import java.util.LinkedList;
  </code>
</pre>
<br>

<strong>Creating an LinkedList</strong>

<ol>
  <li>Import the LinkedList class from the <code>java.util</code> package by adding the following line at the beginning of your Java file:</li>
  <pre><code>import java.util.LinkedList;</code></pre>

  <li>Declare a variable of type LinkedList, specifying the type of elements it will hold within the angle brackets (<code>&lt;&gt;</code>). For example, to create a LinkedList of strings, you can use the following code:</li>
  <pre><code>LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();</code></pre>

  <p>Here, <code>linkedList</code> is the name of the LinkedList, and it will store elements of type String.</p>

  <li>We can add elements to the LinkedList using the <code>add()</code> method. For example, to add a string value to the list, you can use the following code:</li>
  <pre><code class="language-java">linkedList.add("Bangladesh");
linkedList.add("Pakistan");
linkedList.add("India");</code></pre>

  <p>In this example, we added three strings ("Bangladesh", "Pakistan", and "India") to the <code>linkedList</code> LinkedList.</p>
</ol>

<p>Now, we have created a LinkedList, declared a variable to store it, and added elements to it. You can perform various operations on the LinkedList, such as accessing elements, removing elements, checking the size, and more.</p>

<br>
<strong>Commonly used methods for LinkedLists in Java</strong>
<ol>
  <li>
    <strong>add(element)</strong>: Adds the specified element to the end of the LinkedList.
    <pre><code class="language-java">
linkedList.add("apple");
// LinkedList: ["apple"]
    </code></pre>
  </li>
  
  <li>
    <strong>addFirst(element)</strong>: Inserts the specified element at the beginning of the LinkedList.
    <pre><code class="language-java">
linkedList.addFirst("orange");
// LinkedList: ["orange", "apple"]
    </code></pre>
  </li>
  
  <li>
    <strong>addLast(element)</strong>: Appends the specified element to the end of the LinkedList.
    <pre><code class="language-java">
linkedList.addLast("banana");
// LinkedList: ["orange", "apple", "banana"]
    </code></pre>
  </li>
  
  <li>
    <strong>get(index)</strong>: Retrieves the element at the specified index from the LinkedList.
    <pre><code class="language-java">
String element = linkedList.get(0);
// element: "orange"
    </code></pre>
  </li>
  
  <li>
    <strong>set(index, element)</strong>: Replaces the element at the specified index with the given element.
    <pre><code class="language-java">
linkedList.set(0, "grape");
// LinkedList: ["grape", "apple", "banana"]
    </code></pre>
  </li>
  
  <li>
    <strong>remove(index)</strong>: Removes the element at the specified index from the LinkedList.
    <pre><code class="language-java">
linkedList.remove(1);
// LinkedList: ["grape", "banana"]
    </code></pre>
  </li>
  
  <li>
    <strong>removeFirst()</strong>: Removes and returns the first element from the LinkedList.
    <pre><code class="language-java">
String firstElement = linkedList.removeFirst();
// firstElement: "grape"
// LinkedList: ["banana"]
    </code></pre>
  </li>
  
  <li>
    <strong>removeLast()</strong>: Removes and returns the last element from the LinkedList.
    <pre><code class="language-java">
String lastElement = linkedList.removeLast();
// lastElement: "banana"
// LinkedList: []
    </code></pre>
  </li>
  
  <li>
    <strong>size()</strong>: Returns the number of elements in the LinkedList.
    <pre><code class="language-java">
int size = linkedList.size();
// size: 0
    </code></pre>
  </li>
  
  <li>
    <strong>contains(element)</strong>: Checks if the LinkedList contains the specified element and returns a boolean value.
    <pre><code class="language-java">
boolean containsApple = linkedList.contains("apple");
// containsApple: false
    </code></pre>
  </li>
</ol>

<p>These are just a few examples of the commonly used methods available for LinkedList in Java. The LinkedList class provides many more methods for manipulating and working with LinkedLists.</p>

<table>
  <tr>
    <td>
      <h2>Excercise: 17</h2>
      <ol>
        <li>Write a program to create an ArrayList of integers and add elements to it. Then, calculate and print the sum of all the elements in the list.</li>
        <li>Write a program to create a LinkedList of strings and add five country names to it. Display the elements in the LinkedList in reverse order.</li>
        <li>Write a program to create an ArrayList of doubles and find the average of all the elements in the list.</li>
        <li>Write a program to create a LinkedList of characters. Remove all the vowels from the LinkedList and display the updated list.</li>
        <li>Write a program to create an ArrayList of integers. Check if the list contains any even numbers. If it does, remove them from the list and print the updated list.</li>
        <li>Write a program to create a LinkedList of strings and add ten city names to it. Sort the LinkedList in alphabetical order and print the sorted list.</li>
        <li>Write a program to create an ArrayList of strings and remove all the elements that have a length less than 3. Print the updated list.</li>
        <li>Write a program to create a LinkedList of integers. Insert a new element at the middle position of the list and print the updated list.</li>
        <li>Write a program to create an ArrayList of doubles and find the maximum and minimum values in the list. Print both values.</li>
        <li>Write a program to create a LinkedList of characters. Reverse the order of the elements in the LinkedList and print the reversed list.</li>
      </ol>
    </td>
  </tr>
</table>
<br><br>
  <p><strong>HashMap:</strong> In Java, <b>a HashMap is a data structure that stores key-value pairs</b>. It is part of the Java Collections Framework and is implemented by the <code>java.util.HashMap</code> class.</p>
  
  <p>A HashMap provides fast and efficient lookup of values based on their associated keys. It uses a technique called hashing, which involves converting the key into an integer value called a hash code. The hash code is used to determine the storage location, called a bucket, where the key-value pair will be stored.</p>
  
  <p>The main features of a HashMap are as follows:</p>
  
  <ol>
    <li><strong>Key-Value Mapping:</strong> Each element in a HashMap consists of a unique key and its corresponding value. The key can be used to retrieve the associated value from the HashMap.</li>
    <li><strong>No Duplicate Keys:</strong> HashMap does not allow duplicate keys. If an attempt is made to add a key-value pair with a key that already exists in the HashMap, the existing value will be replaced by the new value.</li>
    <li><strong>Fast Retrieval:</strong> HashMap provides constant-time performance for the basic operations like <code>get(key)</code> and <code>put(key, value)</code>. This means that regardless of the size of the HashMap, the time taken to retrieve or insert a key-value pair remains relatively constant.</li>
    <li><strong>Unordered:</strong> The elements in a HashMap are not stored in any particular order. There is no guarantee on the order in which the key-value pairs are iterated or traversed.</li>
  </ol>
  
  <strong>Importing HashMap Class</strong>
  <p>To use a HashMap in Java, you need to import the <code>java.util.HashMap</code> class. You can create a HashMap object and perform operations such as adding key-value pairs, retrieving values based on keys, removing entries, and more.</p>
  <pre>
    <code class="language-java">
import java.util.HashMap;
    </code>
  </pre>
  <p>HashMaps are commonly used in scenarios where fast retrieval of values based on keys is required. They are suitable for tasks like caching, indexing, and efficient storage of data. However, it's important to note that HashMaps do not guarantee the order of elements and are not thread-safe by default.</p>
  <br>
  <strong>Creating a HashMap</strong>
  <ol>
    <li>Declare a variable of type HashMap, specifying the types of the key and value inside the angle brackets (`<>`). For example, you can create a HashMap with String keys and Integer values. For example:</li>
    <pre><code class="language-java">
      HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();
    </code></pre>
    
    <li>Add key-value pairs to the HashMap using the `put(key, value)` method. This allows you to associate a value with a specific key. For example:</li>
    <pre><code class="language-java">
      hashMap.put("apple", 10);
      hashMap.put("banana", 20);
      hashMap.put("orange", 30);
    </code></pre>
  </ol>
  
  <p>Now we can create a HashMap, declare a variable to store it, and add key-value pairs to it. The HashMap provides various operations for retrieving values based on keys, removing entries, and checking the size.</p>
<br>
<strong>Commonly used methods for HashMap in Java</strong>
<ul>
  <li><code>put(key, value)</code>: Inserts the specified key-value pair into the HashMap.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();
hashMap.put("apple", 5);
hashMap.put("banana", 10);
</pre>
</code>
  <li><code>get(key)</code>: Retrieves the value associated with the specified key.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
int quantity = hashMap.get("apple");
System.out.println("Quantity of apples: " + quantity); // Output: Quantity of apples: 5
</pre>
</code>
  <li><code>remove(key)</code>: Removes the key-value pair with the specified key from the HashMap.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
hashMap.remove("banana");
</pre>
</code>
  <li><code>containsKey(key)</code>: Checks if the HashMap contains the specified key.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
if (hashMap.containsKey("apple")) {
  System.out.println("The HashMap contains apples.");
} else {
  System.out.println("The HashMap does not contain apples.");
}
</pre>
</code>
  <li><code>containsValue(value)</code>: Checks if the HashMap contains the specified value.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
if (hashMap.containsValue(5)) {
  System.out.println("The HashMap contains the value 5.");
} else {
  System.out.println("The HashMap does not contain the value 5.");
}
</pre>
</code>
  <li><code>size()</code>: Returns the number of key-value pairs currently stored in the HashMap.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
int size = hashMap.size();
System.out.println("Size of the HashMap: " + size);
</pre>
</code>
  <li><code>isEmpty()</code>: Checks if the HashMap is empty.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
if (hashMap.isEmpty()) {
  System.out.println("The HashMap is empty.");
} else {
  System.out.println("The HashMap is not empty.");
}
</pre>
</code>
  <li><code>keySet()</code>: Returns a Set containing all the keys in the HashMap.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
Set&lt;String&gt; keys = hashMap.keySet();
for (String key : keys) {
  System.out.println("Key: " + key);
}
</pre>
</code>
  <li><code>values()</code>: Returns a Collection containing all the values in the HashMap.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
Collection&lt;Integer&gt; values = hashMap.values();
for (Integer value : values) {
  System.out.println("Value: " + value);
}
</pre>
</code>
  <li><code>entrySet()</code>: Returns a Set containing all the key-value pairs (Map.Entry objects) in the HashMap.</li>
  <p><strong>Example:</strong></p>
  <pre><code class="language-java">
Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hashMap.entrySet();
for (Map.Entry&lt;String, Integer&gt; entry : entries) {
  String key = entry.getKey();
  Integer value = entry.getValue();
  System.out.println("Key: " + key + ", Value: " + value);
}
</pre>
</code>
</ul>

<br><br>
<h2>Stack</h2>

<p><strong>Stack: </strong>In Java, a stack is a data structure that follows the Last-In-First-Out (LIFO) principle. It is a collection of elements with two main operations: push and pop. The push operation adds an element to the top of the stack, while the pop operation removes and returns the topmost element.</p>
  
  <p>The stack can be visualized as a stack of plates, where you can only add or remove plates from the top. The topmost plate is the most recently added one, and removing it exposes the plate below it.</p>
  
  <p>In Java, you have to import <code>java.util.Stack</code> class to work with stacks. Here's an example of how you can use the <code>java.util.Stack</code> class:</p>
  <pre><code class="language-java">
    import java.util.Stack;
    </code></pre>
<strong>Common methods of Stack Class</strong>
<strong>push(element):</strong>
<p>This method pushes an element onto the top of the stack.</p>
<pre><code class="language-java">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
stack.push(1);</code></pre>

<strong>pop():</strong>
<p>This method removes and returns the top element from the stack.</p>
<pre><code class="language-java">int element = stack.pop();</code></pre>

<strong>peek():</strong>
<p>This method returns the top element of the stack without removing it.</p>
<pre><code class="language-java">int topElement = stack.peek();</code></pre>

<strong>isEmpty():</strong>
<p>This method checks if the stack is empty and returns a boolean value accordingly.</p>
<pre><code class="language-java">boolean empty = stack.isEmpty();</code></pre>

<strong>search(element):</strong>
<p>This method searches for an element in the stack and returns its 1-based position from the top. If the element is not found, it returns -1.</p>
<pre><code class="language-java">int position = stack.search(2);</code></pre>

    <strong>Here's is a full form example:</strong>
  <pre><code class="language-java">
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        // Pushing elements onto the stack
        stack.push("Apple");
        stack.push("Banana");
        stack.push("Orange");

        // Popping elements from the stack
        String fruit1 = stack.pop();
        String fruit2 = stack.pop();

        System.out.println(fruit1); // Output: Orange
        System.out.println(fruit2); // Output: Banana
    }
}
  </code></pre>
  
  <p>In this example, we create a stack of strings (<code>Stack&lt;String&gt;</code>) and add three fruits using the <code>push</code> method. Then, we use the <code>pop</code> method to remove the fruits from the stack, retrieving the topmost elements in reverse order. Finally, we print the popped elements, resulting in "Orange" and "Banana" being displayed.</p>
  <p>
    Here's a breakdown of the code:
  </p>
  <ol>
    <li>
      The line <code>import java.util.Stack;</code> imports the <code>Stack</code> class from the <code>java.util</code> package, allowing you to use it in your code.
    </li>
    <li>
      The <code>StackExample</code> class is defined as a public class.
    </li>
    <li>
      The <code>main</code> method is the entry point of the program, where the execution starts.
    </li>
    <li>
      Inside the <code>main</code> method:
      <ul>
        <li>
          A new instance of <code>Stack&lt;String&gt;</code> is created using the <code>new</code> keyword. This creates an empty stack that can hold strings.
        </li>
        <li>
          The <code>push</code> method is used to add elements to the stack. Three strings ("Apple", "Banana", and "Orange") are pushed onto the stack in that order.
        </li>
        <li>
          The <code>pop</code> method is used to remove and retrieve elements from the stack. The topmost element is removed and assigned to the variable <code>fruit1</code>, and then the next topmost element is removed and assigned to <code>fruit2</code>.
        </li>
        <li>
          Finally, the values of <code>fruit1</code> and <code>fruit2</code> are printed using <code>System.out.println</code>, which will display "Orange" and "Banana" respectively.
        </li>
      </ul>
    </li>
  </ol>
  <p>
    So, the output of this code will be:
  </p>
  <pre>
    <code>
Orange
Banana
    </code>
  </pre>
  <p>
    This example demonstrates the <b>Last-In-First-Out (LIFO)</b> behavior of a stack, where the most recently added elements are the first ones to be removed.
  </p>
  <br><br>
  <table>
    <tr>
      <td>
        <h2>Excercise: 18</h2>
        <ol>
          <li>Write a Java program that demonstrates the basic usage of the HashMap class.</li>
          <li>Implement a Java program that utilizes a Stack to check if a given string of parentheses is balanced.</li>
          <li>Write a Java program that uses a HashMap to count the frequency of each word in a given text.</li>
          <li>Create a Java program that uses a Stack to evaluate a postfix expression.</li>
          <li>Implement a Java program that uses a HashMap to store student information (e.g., name and age) and allows searching for a student by their name.</li>
          <li>Write a Java program that uses a Stack to reverse a given string.</li>
          <li>Create a Java program that uses a HashMap to store a dictionary of words and their meanings, and allows searching for a word to retrieve its definition.</li>
          <li>Implement a Java program that utilizes a Stack to convert an infix expression to a postfix expression.</li>
          <li>Write a Java program that uses a HashMap to store employee records (e.g., name, salary, department) and allows adding, removing, and searching for employees based on their ID.</li>
          <li>Create a Java program that uses a Stack to implement a simple calculator that can perform basic arithmetic operations (+, -, *, /).</li>
      </ol>
      </td>
    </tr>
  </table>
</page>
<br><br>
<page>
  <table>
    <tr>
      <td>
        <h4>Thank you so much for purchasing this book :)</h4>
        
      </td>
    </tr>
  </table>
</page>
<script src="main.js"></script>
  <script>hljs.highlightAll();
  
  </script>

<script>
  // Get the current date and time
  var currentDate = new Date();

  // Format the date and time
  var options = { 
    month: 'long', 
    day: 'numeric', 
    year: 'numeric', 
    hour: 'numeric', 
    minute: 'numeric',
    hour12: true
  };
  var formattedDate = currentDate.toLocaleDateString('en-US', options);

  // Update the <span> element with the formatted date and time
  document.getElementById('date').textContent = formattedDate;
</script>



</body>
</html>